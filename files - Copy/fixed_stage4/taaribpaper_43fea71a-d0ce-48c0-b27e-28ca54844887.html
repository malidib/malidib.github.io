```html
<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Léo Boisvert">
  <meta name="author" content="Hélène Verhaeghe">
  <meta name="author" content="Quentin Cappart">
  <title>نحو تمثيل عام لمشكلات التوليف للمقاربات المبنية على التعلم</title>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap');
    html, body {
      font-family: 'Cairo', 'Segoe UI', Tahoma, Geneva, Verdana, Arial, sans-serif;
      background: #f8f9fa;
      color: #222;
      font-size: 22px;
      line-height: 1.7;
      margin: 0;
      padding: 0;
      direction: rtl;
    }
    body {
      max-width: 900px;
      margin: 40px auto 40px auto;
      padding: 32px 24px 32px 24px;
      background: #fff;
      border-radius: 18px;
      box-shadow: 0 4px 32px 0 rgba(0,0,0,0.08);
    }
    header {
      text-align: center;
      margin-bottom: 40px;
    }
    h1.title {
      font-size: 2.3em;
      font-weight: 700;
      color: #1a237e;
      margin-bottom: 0.2em;
      margin-top: 0;
      letter-spacing: 0.01em;
    }
    .author {
      font-size: 1.1em;
      color: #374151;
      margin: 0.1em 0;
      font-weight: 500;
    }
    h1, h2 {
      color: #283593;
      font-weight: 700;
      margin-top: 2.2em;
      margin-bottom: 0.7em;
      border-bottom: 2px solid #e3e6f0;
      padding-bottom: 0.2em;
      letter-spacing: 0.01em;
    }
    h2 {
      font-size: 1.3em;
      margin-top: 1.7em;
    }
    h1.unnumbered {
      border-bottom: none;
      margin-top: 2.5em;
    }
    p {
      margin: 1.1em 0;
      text-align: justify;
    }
    em {
      color: #1565c0;
      font-style: normal;
      font-weight: 600;
    }
    strong {
      color: #b71c1c;
      font-weight: 700;
    }
    a, a:visited {
      color: #1976d2;
      text-decoration: underline;
      word-break: break-all;
    }
    a:hover {
      color: #0d47a1;
      text-decoration: underline;
    }
    code, .math.inline {
      background: #f1f3f4;
      color: #c62828;
      font-family: 'Cairo', 'Consolas', 'monospace';
      font-size: 0.98em;
      border-radius: 4px;
      padding: 0.1em 0.3em;
      margin: 0 0.1em;
    }
    pre {
      background: #f1f3f4;
      color: #263238;
      border-radius: 6px;
      padding: 1em;
      overflow-x: auto;
      font-size: 0.95em;
      margin: 1.2em 0;
      direction: ltr;
      text-align: left;
    }
    dl {
      background: #f5f7fa;
      border-radius: 10px;
      padding: 1.2em 1.5em;
      margin: 2em 0;
      border-right: 4px solid #1976d2;
    }
    dt {
      font-weight: 700;
      color: #283593;
      margin-top: 1.1em;
      margin-bottom: 0.2em;
      font-size: 1.08em;
    }
    dd {
      margin: 0 0 1.1em 0;
      padding: 0 0 0 1.5em;
    }
    ul, ol {
      margin: 1.2em 2.5em 1.2em 0;
      padding: 0 1.5em 0 0;
    }
    li {
      margin-bottom: 0.5em;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      margin: 2em 0;
      background: #fafbfc;
      border-radius: 8px;
      overflow: hidden;
      font-size: 0.98em;
    }
    th, td {
      border: 1px solid #e3e6f0;
      padding: 0.7em 1em;
      text-align: center;
    }
    th {
      background: #e3e6f0;
      color: #283593;
      font-weight: 700;
    }
    tr:nth-child(even) {
      background: #f5f7fa;
    }
    .nodecor {
      text-decoration: none !important;
      color: inherit !important;
      font-weight: inherit !important;
    }
    /* Highlighted boxes for notes or equations */
    .highlight-box {
      background: #e3f2fd;
      border-right: 5px solid #1976d2;
      border-radius: 8px;
      padding: 1em 1.5em;
      margin: 1.5em 0;
      font-size: 1.02em;
    }
    /* For equations and math blocks */
    .math.inline {
      font-family: 'Cairo', 'Consolas', 'monospace';
      font-size: 1em;
      color: #1565c0;
      background: none;
      padding: 0;
      border-radius: 0;
    }
    /* Responsive */
    @media (max-width: 600px) {
      body {
        padding: 10px 2vw 10px 2vw;
        font-size: 18px;
      }
      header {
        margin-bottom: 20px;
      }
      h1.title {
        font-size: 1.3em;
      }
    }
  </style>
</head>
<body>
<header>
  <h1 class="title">نحو تمثيل عام لمشكلات التوليف للمقاربات المبنية على التعلم</h1>
  <p class="author"><span class="nodecor">Léo Boisvert</span></p>
  <p class="author"><span class="nodecor">Hélène Verhaeghe</span></p>
  <p class="author"><span class="nodecor">Quentin Cappart</span></p>
</header>

<h1 id="ملخص">مُلَخَّص</h1>
<p>في السنوات الأخيرة، كان هناك اهتمام متزايد باستخدام المقاربات المبنية على التعلم لحل مشكلات التوليف، سواء من البداية إلى النهاية أو بالتعاون مع خوارزميات التحسين التقليدية. في كلا السيناريوهين، يكمن التحدي في ترميز مشكلات التوليف المستهدفة في صيغة ملائمة لخوارزميات التعلم. لقد اقترحت العديد من الأعمال السابقة تمثيلات مخصّصة للمشكلة، غالبًا على شكل رسم بياني، للاستفادة من مزايا <em>الشبكات العصبية البيانية</em>. ومع ذلك، تفتقر هذه المقاربات إلى العمومية، حيث لا يمكن نقل التمثيل بسهولة من مشكلة توليفية إلى أخرى. على الرغم من أن بعض المحاولات قد أُجريت لسد هذه الفجوة، إلا أنها لا تزال تقدم عمومية جزئية فقط. استجابة لهذا التحدي، يدعو هذا البحث إلى التقدم نحو تمثيل عام كامل لمشكلات التوليف للمقاربات المبنية على التعلم. النهج الذي نقترحه يتضمن بناء رسم بياني عن طريق تحليل أي قيد من مشكلة التوليف إلى شجرة تحليل نحوي مجردة والتعبير عن العلاقات (مثل متغير مشترك في قيد) من خلال الحواف. علاوة على ذلك، نقدم بنية شبكة عصبية بيانية قادرة على التعلم بكفاءة من هذا التمثيل. الأداة المقدمة تعمل على مشكلات التوليف المعبر عنها بتنسيق <span class="nodecor">XCSP3</span>, معالجة جميع القيود المتاحة في مسابقة المسار المصغر لعام <span class="nodecor">2023</span>. تظهر النتائج التجريبية على أربع مشكلات توليفية أن بنيتنا تحقق أداءً مماثلاً للهياكل المعمارية المخصصة مع الحفاظ على العمومية. تتوفر شيفرتنا ونماذجنا المدربة للجمهور على <a href="https://github.com/corail-research/learning-generic-csp" class="uri">https://github.com/corail-research/learning-generic-csp</a>.</p>

<h1 id="مقدمة">مُقَدِّمَة</h1>
<p>لقد جذبت مسائل التحسين التوافقي انتباه باحثي علوم الحاسوب منذ نشأة هذا المجال. وكانت مشكلات التحسين التوافقي، مثل <span class="nodecor">مشكلة البائع المتجول</span> أو <span class="nodecor">الإشباع البولياني</span>، محور بحث مستمر لعقود في مجتمع علوم الحاسوب. يمكننا الآن حل مشكلات كبيرة من هذه الأنواع بكفاءة باستخدام الأساليب الدقيقة (<span class="nodecor">Applegate2009</span>) والإجراءات التقريبية (<span class="nodecor">36b9628e7a874d208624584d8a470985</span>). هذه الاستراتيجيات تمثّل خبرة الخبراء حول بنية المشكلات المُطبقة عليها. وعلى الرغم من نجاحها الواسع في حل المشكلات التوافقية سواء كحل مباشر أو ضمن إجراءات البحث، فقد جذب ظهور <span class="nodecor">التعلم العميق</span> في العديد من المجالات المختلفة (<span class="nodecor">Bahdanau_Cho_Bengio_2016</span>, <span class="nodecor">brown2020language</span>, <span class="nodecor">Krizhevsky_Sutskever_Hinton_2012</span>, <span class="nodecor">mnih2015human</span>) انتباه الباحثين (<span class="nodecor">Prouvost_2020</span>). من بين هياكل <span class="nodecor">التعلم العميق</span>، أثبتت <em>الشبكات العصبية البيانية</em> (<span class="nodecor">GNNs</span>) (<span class="nodecor">Scarselli_Gori_Tsoi_Hagenbuchner_Monfardini_2009</span>) أنها أداة قوية ومرنة لحل هذه المشكلات. ومع ذلك، كما أشار <span class="nodecor">Cappart et al</span>. (2023) (<span class="nodecor">cappart2021combinatorial</span>)، لا يزال من الصعب تبنّي <span class="nodecor">GNN</span> و<span class="nodecor">التعلم الآلي</span> ضمن إجراءات الحل المستخدمة عمليًا. أحد الأسباب هو أنه يجب تصميم وتدريب بنية مخصصة لكل مشكلة توافقية. بالإضافة إلى الموارد الحاسوبية المكلفة المحتملة للتدريب، يتطلب ذلك أيضًا وجود مجموعة تدريب كبيرة وموصوفة.</p>
<p>اعتمد معظم النهج ذات الصلة على إنشاء تمثيل بياني مخصص للمشكلة، مثل <span class="nodecor">NeuroSAT</span> (<span class="nodecor">Selsam2018</span>) الذي يستفيد من ترميز صيغ <span class="nodecor">SAT</span>، أو الأساليب المرتبطة ارتباطًا وثيقًا بـ<span class="nodecor">مشكلة البائع المتجول</span> (<span class="nodecor">Prates_Avelar_Lemos_Lamb_Vardi_2018</span>, <span class="nodecor">joshi2022learning</span>). تعاني هذه الأساليب من محدودية العمومية، حيث لا يمكن تصدير بنية التمثيل ببساطة من مشكلة توافقية إلى أخرى. على الرغم من بعض المحاولات لسد هذه الفجوة، إلا أنها لا تزال توفر عمومية جزئية فقط. على سبيل المثال، اقترح <span class="nodecor">Gasse et al</span>. (2019) (<span class="nodecor">Gasse_Chetelat_Ferroni_Charlin_Lodi_2019</span>) رسمًا ثنائي الطبقات يربط بين المتغيرات والقيود عندما يشارك المتغير في قيد معين. ومع ذلك، فإن هذا النهج يشفر فقط البرمجة الصحيحة المختلطة الثنائية. وفيما بعد، قدم <span class="nodecor">Chalumeau et al</span>. (2021) (<span class="nodecor">chalumeau2021seapearl</span>) رسمًا ثلاثي الطبقات حيث المتغيرات والقيم والقيود هي أنواع مخصصة من الرؤوس. يفتقر هذا الإطار أيضًا إلى العمومية، إذ يتطلب إعادة تدريب النموذج عند تغيير عدد المتغيرات. حتى الآن، كان آخر الاقتراحات هو عمل <span class="nodecor">Marty et al</span>. (2023) (<span class="nodecor">Marty_François_Tessier_Gauthier_Rousseau_Cappart_2023</span>) الذي استخدم رسمًا ثلاثي الطبقات يسمح بإضافة ميزات مخصصة لكل نوع رأس. على الرغم من أن أي مشكلة توافقية يمكن نظريًا ترميزها بهذا الإطار، فإن بعض المعلومات تضيع في العملية. على سبيل المثال، يصعب التمييز بين القيد <span class="math inline">\(3x_1 \leq 4x_2\)</span> والقيد <span class="math inline">\(2x_1 \leq 5x_2\)</span>. فمن جهة، يمكن اعتبارهما <em>عدم مساواة</em>، لكن نفقد تفاصيل المعاملات. ومن جهة أخرى، قد يُفكمَنا كعلاقتين مختلفتين، لكن نفقد الصفة الأساسية للاختلاف. بعبارة أخرى، لم تكن دالة التشفير لديهم حقْنِيّة؛ فقد تستطيع حالات مختلفة مشاركة التمثيل نفسه من دون إمكانية التمييز بينها. علاوة على ذلك، استهدفت تلك التجارب مشكلات نسبية نقية (<em>المجموعة المستقلة القصوى</em>، <em>القطع الأقصى</em>، <em>تلوين الرسم</em>) فقط. وتواجه القيود نفسها في نهج <span class="nodecor">Tönshoff et al</span>. (2022) (<span class="nodecor">Tönshoff_Kisin_Lindner_Grohe_2022</span>).</p>
<p>استنادًا إلى هذا السياق، يتقدم هذا البحث نحو تمثيل عام تمامًا للمشكلات التوافقية المعتمدة على التعلم. فكرتنا الأساسية هي تفكيك أي قيد في حالة المشكلة كـ<em>شجرة بناء نحوي مجردة</em>، ثم ربط العناصر المتماثلة (مثل نفس المتغير أو نفس القيمة) بواسطة حواف. بعد ذلك، نقدم بنية <span class="nodecor">GNN</span> قادرة على استغلال هذا الرسم. لإظهار عمومية هذا النهج، يعمل نموذجنا مباشرة على الحالات المعبر عنها بتنسيق <span class="nodecor"><span style="font-variant: small-caps;">XCSP3</span></span> (<span class="nodecor">Boussemart_Lecoutre_Audemard_Piette_2022</span>)، ويعالج جميع القيود المتاحة في مسابقة المسار المصغر لعام <span class="nodecor">2023</span>. أجرينا التجارب على أربع مشكلات تتضمن قيودًا قياسية وعالمية مثل <span class="nodecor"><span style="font-variant: small-caps;">allDifferent</span></span> (<span class="nodecor">regin1994filtering</span>), <span class="nodecor"><span style="font-variant: small-caps;">table</span></span> (<span class="nodecor">demeulenaere2016compact</span>), <span class="nodecor"><span style="font-variant: small-caps;">negativeTable</span></span> (<span class="nodecor">verhaeghe2017extending</span>), <span class="nodecor"><span style="font-variant: small-caps;">element</span></span> و<span class="nodecor"><span style="font-variant: small-caps;">sum</span></span>، وهدفها التنبؤ بإمكانية الإشباع لنسخ قرارية من المشكلات التوافقية. تظهر النتائج أن بنيتنا العامة تقدم أداءً قريبًا من الهياكل المعمارية المخصصة وتتفوّق على الرسم الثلاثي الطبقات لمارتي وآخرين (2023) (<span class="nodecor">Marty_François_Tessier_Gauthier_Rousseau_Cappart_2023</span>).</p>

<h1 id="ترميز-مثيلـات-المشكلات-التوافقيه-كرسم-بياني">ترميز مثيلات المشكلات التوافقية كرسم بياني</h1>
<p>رسمياً، يُعرّف مثيل المشكلة التوافقية <span class="math inline">\(\mathcal{P}\)</span> على أنه رباعي <span class="math inline">\(\langle X, D(X), C, O \rangle\)</span>، حيث <span class="math inline">\(X\)</span> هي مجموعة المتغيرات، <span class="math inline">\(D(X)\)</span> هي مجموعة النطاقات، <span class="math inline">\(C\)</span> هي مجموعة القيود، و<span class="math inline">\(O\)</span> (<span class="math inline">\(X \to \mathbb{R}\)</span>) هي دالة الهدف. الحل الصالح هو تعيين كل متغير إلى قيمة من نطاقه بحيث تتحقق كل القيود. والحل الأمثل هو ذلك الذي لا يمكن تحسين هدفه عبر حل آخر. هدفنا هو بناء دالة <span class="math inline">\(\Phi: \langle X, D(X), C, O \rangle \mapsto \mathcal{G}(V,f,E)\)</span>، حيث <span class="math inline">\(\mathcal{G}\)</span> رسم بياني و<span class="math inline">\(V\), \(f\), \(E\)</span> هي مجموعات الرؤوس وميزات الرؤوس والحواف على التوالي. نريد أن تكون هذه الدالة <em>حقْنِيّة</em>، أي أن كل ترميز يمثّل مثيل مشكلة توافقية واحدًا فقط. نقترح تحقيق ذلك عبر رسم بياني متجانس غير موجه مكوّن من خمسة أنواع من الرؤوس: <em>المتغيرات</em> (<span class="math inline">\(\textsc{var}\)</span>)، <em>القيود</em> (<span class="math inline">\(\textsc{cst}\)</span>)، <em>القيم</em> (<span class="math inline">\(\textsc{val}\)</span>)، <em>العوامل</em> (<span class="math inline">\(\textsc{ope}\)</span>)، و<em>النموذج</em> (<span class="math inline">\(\textsc{mod}\)</span>). الفكرة هي تقسيم كل قيد إلى سلسلة من العمليات الأولية، وجمع الرؤوس الممثلة لنفس المتغير أو القيمة، وربطها معًا. تشبه هذه العملية بناء شجرة التحليل النحوي المجردة لبرنامج. رسميًا، ينتج عنها رسم بياني <span class="math inline">\(\mathcal{G}(V, f, E)\)</span> حيث <span class="math inline">\(V = V_\textsc{var} \cup V_\textsc{cst} \cup V_\textsc{val} \cup V_\textsc{ope} \cup V_\textsc{mod}\)</span>، و<span class="math inline">\(f = f_\textsc{var} \cup f_\textsc{cst} \cup f_\textsc{val} \cup f_\textsc{ope} \cup f_\textsc{mod}\)</span>، و<span class="math inline">\(E\)</span> هي الحواف التي تربط الرؤوس، وتعكس العلاقات في القيد.</p>

<h1 id="ترميز-المشكلة">ترميز المشكلة</h1>
<p>يمثل الترميز مثيلًا لمشكلة توافقية باعتباره مثالًا تشغيليًا. هناك <span class="nodecor">3</span> رؤوس قيمة (باللون الأخضر) و<span class="nodecor">2</span> رؤوس متغيرة (باللون الأحمر). بما أن <span class="nodecor"><span class="math inline">\(x_1\)</span></span> يمكنه أخذ القيم <span class="nodecor">1</span> و<span class="nodecor">2</span> في نطاقه، فهو متصل بحافتين، وكذلك <span class="nodecor"><span class="math inline">\(x_2\)</span></span>. هناك <span class="nodecor">2</span> رؤوس قيد (باللون الأزرق)، واحدة لعدم المساواة (<span class="nodecor"><span class="math inline">\(\leq\)</span></span>) وواحدة لقيد الجدول (<span class="nodecor"><span class="math inline">\(\textsf{ext}\)</span></span>). توضح المنطقة الرمادية القيد <span class="nodecor"><span class="math inline">\(3x_1 \leq 4x_2\)</span></span>، مع المشغلين (باللون البرتقالي) وعمليتي الضرب: (<span class="nodecor"><span class="math inline">\(\times\)</span></span> بميزة <span class="nodecor">3</span>) لـ<span class="nodecor"><span class="math inline">\(x_1\)</span></span> على الجانب الأيمن (<span class="nodecor"><span class="math inline">\(\textsf{rhs}\)</span></span>) وآخر (<span class="nodecor"><span class="math inline">\(\times\)</span></span> بميزة <span class="nodecor">4</span>) لـ<span class="nodecor"><span class="math inline">\(x_2\)</span></span> على الجانب الأيسر (<span class="nodecor"><span class="math inline">\(\textsf{lhs}\)</span></span>). يوضح المشغلان <span class="nodecor"><span class="math inline">\(\textsf{rhs}\)</span></span> و<span class="nodecor"><span class="math inline">\(\textsf{lhs}\)</span></span> جانبي المعادلة، وهو أمر ضروري للتمييز بين <span class="nodecor"><span class="math inline">\(3x_1 \leq 4x_2\)</span></span> و<span class="nodecor"><span class="math inline">\(3x_1 \geq 4x_2\)</span></span>، ويرتبط بالقيد المناسب. يتم التعبير عن قيد الجدول <span class="nodecor"><span class="math inline">\(\textsc{table}([x_1,x_2],[(1,2),(2,3)])\)</span></span> بطريقة مماثلة عبر زوجين <span class="nodecor"><span class="math inline">\(t_1\)</span></span> و<span class="nodecor"><span class="math inline">\(t_2\)</span></span>. أخيرًا، يتصل رأس النموذج (باللون الأصفر) بالقيدين وبالمتغير <span class="nodecor"><span class="math inline">\(x_1\)</span></span> كجزء من دالة الهدف.</p>
<p>كملاحظة ختامية، يمكن استخدام هذا الترميز لتمثيل أي مثيل لمشكلة توافقية بطريقة فريدة. يتطلب ذلك تطوير محلل لكل قيد يحدد كيفية تفكيكه إلى مشغلين ومتغيرات. نحن ندعم حاليًا جميع القيود المدرجة في نص XCSP3-core (<span class="nodecor">Boussemart_Lecoutre_Audemard_Piette_2022</span>) والمستخدمة في مسارات الحل المصغر لمسابقة <span class="nodecor">XCSP-2023</span>: المساواة الثنائية، الجدول، الجدول السلبي، الجدول القصير، العنصر، والمجموع. يحتوي مستودعنا على الوثائق اللازمة لبناء الرسم البياني لأي مثيل بصيغة XCSP3-core ووصف جميع الميزات المدعومة.</p>

<h1 id="sec:gnn">التعلم من الترميز باستخدام شبكة عصبية بيانية</h1>
<p>لتحقيق الخطوة التالية و<em>التعلم</em> من هذا التمثيل، قمنا بتصميم بنية <em>شبكة عصبية بيانية</em> مخصصة للاستفادة من هذا الترميز. شبكة عصبية بيانية هي بنية متخصصة مصممة لحساب التمثيل الكامن (التضمين) لكل عقدة في الرسم البياني المعطى (<span class="nodecor">Scarselli_Gori_Tsoi_Hagenbuchner_Monfardini_2009</span>) عبر تجميع المعلومات من العقد المجاورة بشكل تكراري. يُشار إلى كل خطوة تجميع بـ<em>طبقة</em> وتتضمن أوزانًا قابلة للتعلم. توجد عدة طرق للتجميع معروفة في الأدبيات (<span class="nodecor">li2016gated</span>, <span class="nodecor">monti2017geometric</span>, <span class="nodecor">velivckovicgraph</span>). النموذج قابل للتفاضل ويمكن تدريبه باستخدام الانحدار التدريجي.</p>
<p>لنفترض أن <span class="math inline">\(\mathcal{G}(V, f, E)\)</span> هو الترميز البياني المحسوب مسبقًا، وليكن <span class="math inline">\(h^{[i]}_{t,v} \in \mathbb{R}^{p}\)</span> التمثيل المتجهي للبُعد <span class="math inline">\(p\)</span> للرأس <span class="math inline">\(v \in V_t\)</span> في التكرار <span class="math inline">\(i \in \{0, \ldots, I\}\)</span>. عملية الاستدلال في شبكة عصبية بيانية تُعرف بـ<em>تمرير الرسالة</em>، حيث نحسب التمثيلات الجديدة <span class="math inline">\(h^{[i+1]}_{t,v}\)</span> من السابقة. أولاً، نعيّن <span class="math inline">\(h^{[0]}_{t,v} = f_{t,v}\)</span> لكل رأس، حيث <span class="math inline">\(f_{t,v}\)</span> هو متجه الميزات الخاص به. ثم نجري <span class="math inline">\(I\)</span> خطوات من تمرير الرسالة، كل منها يتضمن تجميع الرسائل من الجيران، تحويلها عبر <span class="math inline">\(\mathsf{MLP}^{\mathsf{in}}_{t_1,t_2}\)</span> مخصصة لكل نوع حافة ودمجها (<span class="math inline">\(\bigoplus\)</span>)، ثم تحديث التمثيل بواسطة خلية LSTM (<span class="math inline">\(t\)</span> خلية لكل نوع). أخيرًا، نمرر <span class="math inline">\(h^{[I]}_{t,v}\)</span> عبر <span class="math inline">\(\mathsf{MLP}^{\mathsf{out}}_{t}\)</span> للحصول على مخرجات <span class="math inline">\( \nu_{t,v}\)</span>، ثم نوسّطها ونطبق سيجمويد لإنتاج التنبؤ <span class="math inline">\(\hat{y}\)</span>.</p>
<div class="highlight-box">
  <p><span class="math inline">\(\triangleright\)</span> <strong>Pre:</strong> <span class="math inline">\(\mathcal{G}(V_{\textsc{var},\textsc{cst},\textsc{val},\textsc{ope},\textsc{mod}}, f_{\textsc{var},\textsc{cst},\textsc{val},\textsc{ope},\textsc{mod}}, E)\)</span> هو الترميز البياني.</p>
  <p><span class="math inline">\(\triangleright\)</span> <strong>Pre:</strong> <span class="math inline">\( \mathcal{T} : \{\textsc{var},\textsc{val},\textsc{cst},\textsc{ope},\textsc{mod}\}\)</span> هي مجموعة <em>أنواع الرؤوس</em>.</p>
  <p><span class="math inline">\(\triangleright\)</span> <strong>Pre:</strong> <span class="math inline">\(I\)</span> هو عدد تكرارات شبكة العصبية البيانية.</p>
  <p><span class="math inline">\(h^{[0]}_{t,v} := f_{t,v} ~ ~ ~ \forall v \in V_t, \forall t \in \mathcal{T}\)</span> [eql:1]</p>
  <p><span class="math inline">\(\gamma^{[0]}_{t,v} := 0 ~ ~ ~ \forall v \in V_t, \forall t \in \mathcal{T}\)</span> [eql:2]</p>
  <p><span class="math inline">\( \nu_{t,v} := \mathsf{MLP}^{\mathsf{out}}_{t}\bigl(h^{[I]}_{t,v}\bigr) ~ ~ \forall v \in V_t, \forall t \in \mathcal{T}\)</span> [eql:6]</p>
  <p><span class="math inline">\(\hat{y} := \sigma\Bigl(\tfrac{1}{|\mathcal{T}|\times |V|}\sum_{t \in \mathcal{T}}\sum_{v \in V_t}\nu_{t,v}\Bigr)\)</span> [eql:7]</p>
  <p><span class="math inline">\(\hat{y}\)</span> [eql:8]</p>
</div>

<h1 id="sec:exp">التجارب</h1>
<p>يقيم هذا القسم منهجيتنا على المهام التوافقية، مع التركيز على أربعة مشكلات: مشكلة الإشباع البولياني (<span style="font-variant: small-caps;">SAT</span>)، تلوين الرسم البياني (<span style="font-variant: small-caps;">COL</span>)، مشكلة الحقيبة (<span style="font-variant: small-caps;">Knap</span>)، ومشكلة البائع المتجول (<span style="font-variant: small-caps;">TSP</span>) مع نماذج <span style="font-variant: small-caps;">TSP-Ext</span> (قيد الجدول) و<span style="font-variant: small-caps;">TSP-Elem</span> (قيد العنصر). قمنا بتدريب النماذج على النسخ القرارِية من المشكلات، مستوضحين ما إذا كان هناك حل بتكلفة أقل من الهدف <span class="math inline">\(k\)</span>. وفي حالة عدم وجود دالة هدف، تصبح مسألة إشباع محدودة بسيطة (مثل <span style="font-variant: small-caps;">SAT</span>) حيث يهدف النموذج إلى تحديد وجود حل. قارنا منهجيتنا مع الهياكل المعمارية المخصصة لكل مشكلة والرسم الثلاثي الطبقات لمارتي وآخرين (2023) (<span class="nodecor">Marty_François_Tessier_Gauthier_Rousseau_Cappart_2023</span>). استخرجنا تمثيلهم البياني واستخدمناه في شبكتنا. المقياس التقييمي المعتمد هو الدقة في التنبؤ الصحيح بوجود الحل في النسخة القرارِية. تتبع التفاصيل بروتوكولات تجريبية وتفاصيل التنفيذ.</p>
<dl>
<dt>مشكلة الإشباع البولياني.</dt>
<dd><p>تم إنشاء النماذج باستخدام المولد العشوائي لـ<span class="nodecor">Selsam et al</span>. (2018) (<span class="nodecor">Selsam2018</span>). باختصار، يولّد هذا المولد أزواجًا من نماذج <span style="font-variant: small-caps;">SAT</span> ذات <span class="math inline">\(n\)</span> متغيرات عن طريق إضافة شروط عشوائية حتى تصبح المسألة غير قابلة للإشباع، ثم يُقلّب إشارة إحدى المتغيرات لجعلها قابلة للإشباع. في المتوسط، تضمّ الشروط نحو <span class="nodecor">8</span> حدودًا. ضمنا كلا توزيعَي القابلة وغير القابلة للإشباع في مجموعة البيانات. كما في العمل الأصلي، أنشأنا مجموعة تدريب مؤلفة من <span class="nodecor">3,980,000</span> نموذجًا ومجموعة تحقق من <span class="nodecor">20,000</span>.</p>
</dd>
<dt>مشكلة البائع المتجول.</dt>
<dd><p>تم إنشاء النماذج باستخدام المولد العشوائي لـ<span class="nodecor">Prates et al</span>. (2018) (<span class="nodecor">Prates_Avelar_Lemos_Lamb_Vardi_2018</span>). يتكوّن الجيل من: (1) توزيع <span class="math inline">\(n\)</span> نقاط عشوائية في مربع <span class="math inline">\((\sqrt{2}/2 \times \sqrt{2}/2)\)</span>، (2) حساب مصفوفة المسافات الإقليدية، و(3) حل المثيل بالمحلل Concorde (<span class="nodecor">applegate2006concorde</span>) للحصول على التكلفة المثلى <span class="math inline">\(C^*\)</span>. ثم جنّا نموذجين: واحد قابل بالهدف <span class="nodecor">1.02</span>×<span class="math inline">\(C^*\)</span> وآخر غير قابل بالهدف <span class="nodecor">0.98</span>×<span class="math inline">\(C^*\)</span>. أنشأنا نموذجين <span style="font-variant: small-caps;">TSP</span>: الأول باستخدام قيد التمديد (<span style="font-variant: small-caps;">TSP-Ext</span>)، والثاني قيد العنصر (<span style="font-variant: small-caps;">TSP-Elem</span>)، لدراسة تأثير النموذج على الترميز البياني والأداء. كالسابق، بنينا مجموعة بيانات لمدن <span class="math inline">\(n\)</span> تفاوتت بين <span class="nodecor">20</span> و<span class="nodecor">40</span> مدينة. استخدمنا <span class="nodecor">850,000</span> نموذجًا للتدريب و<span class="nodecor">50,000</span> للتحقق.</p>
</dd>
<dt>تلوين الرسم البياني.</dt>
<dd><p>اتبعنا مولد <span class="nodecor">lemos2019graph</span> لإنشاء رسومات من <span class="nodecor">40</span> إلى <span class="nodecor">60</span> رأسًا. لكل رسوم، نضيف حافة واحدة لتغيير قابلية التلوين بـ<span class="math inline">\(k\)</span>. ننتج نماذجَين: قيمة مثلى = <span class="math inline">\(k\)</span> وأخرى أعلى. يستفيد ترميزنا من قيد <span class="math inline">\(\neq\)</span>. استخدمنا <span class="nodecor">140,000</span> نموذجًا للتدريب و<span class="nodecor">10,000</span> للتحقق.</p>
</dd>
<dt>مشكلة الحقيبة.</dt>
<dd><p>أنشأنا نماذجًا من <span class="nodecor">20</span> إلى <span class="nodecor">40</span> عنصرًا وحللناها لإيجاد القيمة المثلى <span class="math inline">\(V^*\)</span>. ثم جنى نموذجين قابل وغير قابل بتحقيق بالهدفين <span class="nodecor">1.02</span>×<span class="math inline">\(V^*\)</span> و<span class="nodecor">0.98</span>×<span class="math inline">\(V^*\)</span> على التوالي. يستفيد ترميزنا من قيد <span style="font-variant: small-caps;">sum</span>. استخدمنا <span class="nodecor">950,000</span> نموذجًا للتدريب و<span class="nodecor">50,000</span> للتحقق.</p>
</dd>
<dt>تفاصيل التنفيذ.</dt>
<dd><p>درّبنا كل النماذج باستخدام PyTorch (<span class="nodecor">paszke2019pytorch</span>) وPyTorch-Geometric (<span class="nodecor">fey2019fast</span>) على بطاقة Nvidia V100 بسعة <span class="nodecor">32</span> GB لمدة تصل إلى <span class="nodecor">4</span> أيام أو حتى التقارب. اخترنا النموذج الأفضل على مجموعة التحقق. لضمان عدالة المقارنة بين الهياكل المعمارية الخاصة والعامة، استخدمنا بطاقة واحدة وضبّطنا عدد الوحدات الخفية في MLP وLSTM. وللنماذج المخصصة، احتفظنا بنفس المعايير الفائقة المذكورة في منشوراتها الأصلية. درّبنا كل النماذج بمُحسِّن Adam (<span class="nodecor">KingmaB14</span>) مع جدول معدل التعلم وتخميد وزن <span class="nodecor"><span class="math inline">\(10^{-8}\)</span></span>. يمكن العثور على كافة المعايير الفائقة في الكود المرفق. جميع نماذجنا معبر عنها بصيغة <span style="font-variant: small-caps;">XCSP3</span>.</p>
</dd>
</dl>
<p>قمنا بتنفيذ محلل لبناء الرسم البياني حسب هذا الترميز. شيفرتنا ونماذجنا المدربة متاحة للجميع.</p>

<h2 id="النتائج-دقة-المناهج">النتائج: دقة المناهج</h2>
<p>يوضح الجدول [table:main-results] الدقة في التنبؤ بالإجابة الصحيحة على مجموعة التحقق لكل مشكلة وخط أساس. من المثير للاهتمام أن منهجنا يحقق أداءً مماثلًا للهياكل المعمارية المخصصة لكل مشكلة. نرى في ذلك نتيجة واعدة، إذ يمكن استخدام منهجنا مباشرة دون الحاجة لتصميم هيكل جديد مخصص. على النقيض، تراجع منهج <span class="nodecor">Marty_François_Tessier_Gauthier_Rousseau_Cappart_2023</span> في جميع المشكلات باستثناء تلوين الرسم البياني، وذلك لأن هذا التمثيل لا يحافظ على البنية التركيبية للقيود المعقدة.</p>
<p>بينما يحقق <span style="font-variant: small-caps;">TSP-Elem</span> نتائج قريبة من النموذج المخصص لـTSP، يقصر <span style="font-variant: small-caps;">TSP-Ext</span> بشكل واضح. هذا يبيّن أهمية اختيار نموذج إدخال مناسب للترميز. على سبيل المثال، ينتج <span style="font-variant: small-caps;">TSP-Elem</span> ترميزًا بحجم <span class="math inline">\(1841\)</span> رأسًا و<span class="math inline">\(13042\)</span> حافة، بينما يولّد <span style="font-variant: small-caps;">TSP-Ext</span> رسمًا بيانيًا مكوّنًا من <span class="math inline">\(5661\)</span> رأسًا و<span class="math inline">\(28322\)</span> حافة لنفس المثيل، مما يصعب التدريب بسبب الحجم الأكبر.</p>

<h2 id="تحليل-التعميم-على-نماذج-أكبر">تحليل: التعميم على نماذج أكبر</h2>
<p>يُظهر الشكل المرجعي <span class="nodecor">fig:generalization</span> قدرة التعميم لنموذجنا، دون إعادة تدريب، على نماذج جديدة من <span class="nodecor">60</span>، <span class="nodecor">80</span> و<span class="nodecor">100</span> متغير (5000 نموذج لكل حجم). نلاحظ أن تمثيلنا العام يوفر تعميمًا أفضل من الهياكل المعمارية المخصصة لمشكلتَي <span class="nodecor">SAT</span> و<span class="nodecor">TSP</span>. بشكل لافت، يقدم <span class="nodecor">TSP-Elem</span> تعميمًا أفضل بكثير من <span class="nodecor">TSP-Ext</span>، مما يؤكد أثر نموذج الإدخال وحجم الرسم البياني. من المثير للاهتمام أيضًا قدرة التعميم القوية للنموذج المخصص لمشكلة الحقيبة، وهو ما تعزى أوليًا إلى دالة تجميع في GNN تعتمد على مجموع موزون. دراسة الأسباب الجذرية لهذا التعلم المتعمم محل بحث مستقبلي.</p>

<h2 id="المناقشة-القيود-والتحديات">المناقشة: القيود والتحديات</h2>
<p>على الرغم من النتائج المشجعة، هناك بعض التحديات. أولًا، زمن التدريب طويل حتى على حالات صغيرة نسبيًا، ويرجع ذلك جزئيًا إلى حجم الرسومات الناتجة. هذا يفتح الباب لطرق ضغط خاصة تقلّص حجم الترميز دون فقدان المعلومات، مثل قيود <span class="nodecor">smartTable</span> (<span class="nodecor">mairy2015smart</span>). كما يبرز أهمية نموذج إدخال ينتج تضمينًا أصغر (مثًلا <span class="nodecor">TSP-Elem</span> مقارنة بـ<span class="nodecor">TSP-Ext</span>). ثانيًا، اقتصرت المهمة الحالية على حل النسخ القرارِية من المشكلات بشكل من البداية إلى النهاية. وسيكون الدمج مع إجراءات حل كاملة، كما اقترح <span class="nodecor">Gasse_Chetelat_Ferroni_Charlin_Lodi_2019</span> للبرمجة المختلطة الثنائية و<span class="nodecor">cappart2021combining</span> للبرمجة بالقيود، خطوة مهمة. أخيرًا، يعد اختبار تعميم النموذج المدرب على مشكلة معينة (مثل <span class="nodecor">TSP</span>) على نسخة مشابهة (مثل <span class="nodecor">TSP</span> مع نوافذ زمنية) محورًا مثيرًا للاستكشاف.</p>

<h1 id="الخلاصة-والآفاق">الخلاصة والآفاق</h1>
<p>قدم هذا البحث نسخة أولية من إجراء عام لترميز حالات المشكلات التركيبية إلى رسم بياني مناسب للتعلم. الرمز المقترح حقْنِيّ، بحيث يشير كل ترميز لمثيل وحيد للمشكلة. بالإضافة إلى ذلك، اقترحنا بنية شبكة عصبية بيانية للتعلم من هذا التمثيل. أظهرت النتائج التجريبية أن منهجنا يحقق أداءً مقاربًا للهياكل المعمارية المخصصة دون الحاجة لتصميم يدوي لممثل خاص. جميع قيود مسابقة المسار المصغر لعام <span class="nodecor">2023</span> مدعومة حاليًا؛ وإضافة قيود جديدة تتطلب فقط تنفيذ محلل جديد. خطواتنا القادمة تشمل تطبيق النهج على مشكلات أكبر وأكثر تعقيدًا وعلى مهام تركيبية أخرى (مثل تعلم الاستدلالات الفرعية).</p>

<h1 id="الشكر-والتقدير" class="unnumbered">الشكر والتقدير</h1>
<p>تم تمويل هذا البحث بشكل رئيسي بفضل منحة اكتشاف <span class="nodecor">NSERC</span> (كندا) التي يحملها كوينتن كابارت. كما تلقى تمويلًا من برنامج الاتحاد الأوروبي للبحث والابتكار <span class="nodecor">Horizon 2020</span> بموجب اتفاقية منحة رقم <span class="nodecor">101070149</span>، مشروع <span class="nodecor">Tuples</span>.</p>
</body>
</html>
```
**ملاحظات:**
- تم تحسين الخطوط والألوان والتباعد والحدود والظلال لجعل الورقة أكثر جاذبية واحترافية.
- تم الحفاظ على النص كاملاً دون أي تغيير في الكلمات أو المحتوى.
- تم التأكد من عدم وجود أخطاء HTML، وجميع العناصر مغلقة بشكل صحيح.
- تم تحسين عرض المعادلات، الكود، القوائم، والعناوين.
- تم جعل التصميم متجاوبًا مع الشاشات الصغيرة.
- تم إبراز الملاحظات/المربعات المهمة بصندوق مميز.
- تم الحفاظ على جميع الروابط، الأسماء، والاقتباسات كما هي.