<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Léo Boisvert">
  <meta name="author" content="Hélène Verhaeghe">
  <meta name="author" content="Quentin Cappart">
  <title>نحو تمثيل عام لمشكلات التوليف للمقاربات المبنية على التعلم</title>
  <style type="text/css">code{white-space: pre;}</style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <style>body { direction: rtl; font-size: 22px; }</style>
</head>
<body>
<header>
<h1 class="title">نحو تمثيل عام لمشكلات التوليف للمقاربات المبنية على التعلم</h1>
<p class="author"><span class="nodecor">Léo Boisvert</span></p>
<p class="author"><span class="nodecor">Hélène Verhaeghe</span></p>
<p class="author"><span class="nodecor">Quentin Cappart</span></p>
</header>
<h1 id="ملخص">مُلَخَّص</h1>
<p>في السنوات الأخيرة، كان هناك اهتمام متزايد باستخدام المقاربات المبنية على التعلم لحل مشكلات التوليف، سواء من البداية إلى النهاية أو بالتعاون مع خوارزميات التحسين التقليدية. في كلا السيناريوهين، يكمن التحدي في ترميز مشكلات التوليف المستهدفة بصيغة ملائمة لخوارزميات التعلم. لقد اقترحت العديد من الأعمال السابقة تمثيلات مخصّصة للمشكلة، غالبًا على شكل رسم بياني، للاستفادة من مزايا <em>الشبكات العصبية البيانية</em>. ومع ذلك، تفتقر هذه المقاربات إلى العمومية؛ إذ لا يمكن نقل التمثيل بسهولة من مشكلة توليفية إلى أخرى. على الرغم من بعض المحاولات لسد هذه الفجوة، فإنها تقدم عمومية جزئية فقط. استجابةً لهذا التحدي، يقدم هذا البحث خطوةً نحو تمثيل عام شامل لمشكلات التوليف للمقاربات المبنية على التعلم. يتضمن النهج المقترح إنشاء رسم بياني من خلال تحليل أي قيد في مشكلة التوليف إلى شجرة تحليل نحوي مجردة، والتعبير عن العلاقات (مثل متغير مشترك في قيد) بواسطة الحواف. علاوة على ذلك، نقدم بنية شبكة عصبية بيانية قادرة على التعلم بكفاءة من هذا التمثيل. الأداة المقدمة تعمل على مشكلات التوليف المعبر عنها بتنسيق <span class="nodecor">XCSP3</span>، وتعالج جميع القيود المتاحة في مسابقة المسار المصغر لعام <span class="nodecor">2023</span>. تظهر النتائج التجريبية على أربع مشكلات توليفية أن بنيتنا تحقق أداءً مماثلاً للهياكل المعمارية المخصصة مع الحفاظ على العمومية. تتوفر شيفرتنا ونماذجنا المدربة للجمهور على <a href="https://github.com/corail-research/learning-generic-csp" class="uri">https://github.com/corail-research/learning-generic-csp</a>.</p>
<h1 id="مقدمة">مُقَدِّمَة</h1>
<p>لقد جذبت مسائل التحسين التوافقي انتباه باحثي علوم الحاسوب منذ نشأة هذا المجال. وكانت مشكلات التحسين التوافقي، مثل <span class="nodecor">مشكلة البائع المتجول</span> أو <span class="nodecor">الإشباع البولياني</span>، محور بحث مستمر لعقود في مجتمع علوم الحاسوب. يمكننا الآن حل مشكلات كبيرة من هذه الأنواع بكفاءة باستخدام الأساليب الدقيقة (<span class="nodecor">Applegate2009</span>) والإجراءات التقريبية (<span class="nodecor">36b9628e7a874d208624584d8a470985</span>). تجسّد هذه الاستراتيجيات خبرات الخبراء حول بنية المشكلات المطبّقة عليها. وعلى الرغم من نجاحها الواسع في حل المشكلات التوافقية سواء كحل مباشر أو ضمن إجراءات البحث، أثار ظهور <span class="nodecor">التعلم العميق</span> في العديد من المجالات المختلفة (<span class="nodecor">Bahdanau_Cho_Bengio_2016</span>, <span class="nodecor">brown2020language</span>, <span class="nodecor">Krizhevsky_Sutskever_Hinton_2012</span>, <span class="nodecor">mnih2015human</span>) اهتمام الباحثين (<span class="nodecor">Prouvost_2020</span>). من بين نماذج <span class="nodecor">التعلم العميق</span>، أثبتت <em>الشبكات العصبية البيانية</em> (<span class="nodecor">GNNs</span>) (<span class="nodecor">Scarselli_Gori_Tsoi_Hagenbuchner_Monfardini_2009</span>) أنها أداة قوية ومرنة لحل هذه المشكلات. ومع ذلك، كما أشار <span class="nodecor">Cappart et al</span>. (2023) (<span class="nodecor">cappart2021combinatorial</span>)، لا يزال من الصعب تبنّي <span class="nodecor">GNN</span> و<span class="nodecor">التعلم الآلي</span> ضمن إجراءات الحل المستخدمة عمليًا. أحد الأسباب هو وجوب تصميم وتدريب بنية مخصصة لكل مشكلة توافقية، بالإضافة إلى الحاجة لمجموعة تدريب كبيرة وموصوفة بدقة.</p>
<p>اعتمد معظم النهج ذات الصلة على إنشاء تمثيل بياني مخصص للمشكلة، مثل <span class="nodecor">NeuroSAT</span> (<span class="nodecor">Selsam2018</span>) الذي يستفيد من ترميز صيغ <span class="nodecor">SAT</span>، أو الأساليب المرتبطة ارتباطًا وثيقًا بـ<span class="nodecor">مشكلة البائع المتجول</span> (<span class="nodecor">Prates_Avelar_Lemos_Lamb_Vardi_2018</span>, <span class="nodecor">joshi2022learning</span>). تعاني هذه الأساليب من محدودية العمومية، إذ لا يمكن نقل بنية التمثيل ببساطة من مشكلة توافقية إلى أخرى. على الرغم من بعض المحاولات لسد هذه الفجوة، فإنها توفر عمومية جزئية فقط. على سبيل المثال، اقترح <span class="nodecor">Gasse et al</span>. (2019) (<span class="nodecor">Gasse_Chetelat_Ferroni_Charlin_Lodi_2019</span>) رسمًا ثنائي الطبقات يربط بين المتغيرات والقيود عندما يشارك المتغير في قيد معين، لكنه يشفّر فقط البرمجة الصحيحة المختلطة الثنائية. وفيما بعد، قدم <span class="nodecor">Chalumeau et al</span>. (2021) (<span class="nodecor">chalumeau2021seapearl</span>) رسمًا ثلاثي الطبقات حيث المتغيرات والقيم والقيود هي أنواع مخصصة من الرؤوس. يفتقر هذا الإطار أيضًا إلى العمومية؛ إذ يتطلب إعادة تدريب النموذج عند تغيير عدد المتغيرات. حتى الآن، كان آخر الاقتراحات عمل <span class="nodecor">Marty et al</span>. (2023) (<span class="nodecor">Marty_François_Tessier_Gauthier_Rousseau_Cappart_2023</span>) الذي استخدم رسمًا ثلاثي الطبقات يسمح بإضافة ميزات مخصصة لكل نوع رأس. على الرغم من أن أي مشكلة توافقية يمكن نظريًا ترميزها بهذا الإطار، فإن بعض المعلومات تضيع في العملية. على سبيل المثال، يصعب التمييز بين القيد <span class="math inline">\(3x_1 \leq 4x_2\)</span> والقيد <span class="math inline">\(2x_1 \leq 5x_2\)</span>. فمن جهة، يمكن اعتباره <em>عدم مساواة</em>، لكننا نفقد تفاصيل المعاملات؛ ومن جهة أخرى، قد نفكّره كعلاقتين مختلفتين، لكن نفقد الصفة الأساسية للاختلاف. بعبارة أخرى، لم تكن دالة التشفير لديهم حقْنِيّة؛ فقد تشترك حالات مختلفة في التمثيل نفسه من دون إمكانية التمييز بينها. علاوة على ذلك، استهدفت تلك التجارب مشكلات نسبية نقية (<em>المجموعة المستقلة القصوى</em>، <em>القطع الأقصى</em>، <em>تلوين الرسم</em>) فقط، كما تواجه القيود نفسها في نهج <span class="nodecor">Tönshoff et al</span>. (2022) (<span class="nodecor">Tönshoff_Kisin_Lindner_Grohe_2022</span>).</p>
<p>استنادًا إلى هذا السياق، يتقدم هذا البحث نحو تمثيل عام تمامًا للمشكلات التوافقية المعتمدة على التعلم. فكرتنا الأساسية هي تفكيك أي قيد في مثيل المشكلة إلى <em>شجرة بناء نحوي مجردة</em>، ثم ربط العناصر المتماثلة (مثل نفس المتغير أو القيمة) بواسطة حواف. بعد ذلك، نقدم بنية <span class="nodecor">GNN</span> قادرة على استغلال هذا الرسم. لإظهار عمومية هذا النهج، يعمل نموذجنا مباشرة على الحالات المعبر عنها بتنسيق <span class="nodecor"><span style="font-variant: small-caps;">XCSP3</span></span> (<span class="nodecor">Boussemart_Lecoutre_Audemard_Piette_2022</span>)، ويعالج جميع القيود المتاحة في مسابقة المسار المصغر لعام <span class="nodecor">2023</span>. أجرينا التجارب على أربع مشكلات تشمل قيودًا قياسية وعالمية مثل <span class="nodecor"><span style="font-variant: small-caps;">allDifferent</span></span> (<span class="nodecor">regin1994filtering</span>), <span class="nodecor"><span style="font-variant: small-caps;">table</span></span> (<span class="nodecor">demeulenaere2016compact</span>), <span class="nodecor"><span style="font-variant: small-caps;">negativeTable</span></span> (<span class="nodecor">verhaeghe2017extending</span>), <span class="nodecor"><span style="font-variant: small-caps;">element</span></span> و<span class="nodecor"><span style="font-variant: small-caps;">sum</span></span>، وهدفها التنبؤ بإمكانية الإشباع لنسخ قرارية من المشكلات التوافقية. تظهر النتائج أن بنيتنا العامة تقدم أداءً قريبًا من الهياكل المعمارية المخصصة وتتفوّق على الرسم الثلاثي الطبقات لمارتي وآخرين (2023) (<span class="nodecor">Marty_François_Tessier_Gauthier_Rousseau_Cappart_2023</span>).</p>
<h1 id="ترميز-مثيلـات-المشكلات-التوافقيه-كرسم-بياني">ترميز مثيلات المشكلات التوافقية كرسم بياني</h1>
<p>رسميًا، يُعرّف مثيل المشكلة التوافقية <span class="math inline">\(\mathcal{P}\)</span> على أنه رباعي <span class="math inline">\(\langle X, D(X), C, O \rangle\)</span>، حيث <span class="math inline">\(X\)</span> هي مجموعة المتغيرات، <span class="math inline">\(D(X)\)</span> مجموعة النطاقات، <span class="math inline">\(C\)</span> مجموعة القيود، و<span class="math inline">\(O\)</span> (<span class="math inline">\(X \to \mathbb{R}\)</span>) دالة الهدف. الحل الصالح هو تعيين كل متغير إلى قيمة من نطاقه بحيث تتحقق كل القيود. والحل الأمثل هو الذي لا يمكن تحسين قيمة هدفه من خلال حل آخر. هدفنا هو بناء دالة <span class="math inline">\(\Phi: \langle X, D(X), C, O \rangle \mapsto \mathcal{G}(V,f,E)\)</span>، حيث <span class="math inline">\(\mathcal{G}\)</span> رسم بياني و<span class="math inline">\(V\), \(f\), \(E\)</span> مجموعات الرؤوس وميزات الرؤوس والحواف على التوالي. نريد أن تكون هذه الدالة <em>حقْنِيّة</em>، أي أن كل ترميز يمثّل مثيل مشكلة توافقية واحدًا فقط. نقترح تحقيق ذلك عبر رسم بياني متجانس غير موجه مكوّن من خمسة أنواع من الرؤوس: <em>المتغيرات</em> (<span class="math inline">\(\textsc{var}\)</span>)، <em>القيود</em> (<span class="math inline">\(\textsc{cst}\)</span>)، <em>القيم</em> (<span class="math inline">\(\textsc{val}\)</span>)، <em>العوامل</em> (<span class="math inline">\(\textsc{ope}\)</span>)، و<em>النموذج</em> (<span class="math inline">\(\textsc{mod}\)</span>). الفكرة هي تقسيم كل قيد إلى سلسلة من العمليات الأولية، وجمع الرؤوس الممثلة لنفس المتغير أو القيمة، وربطها معًا. تشبه هذه العملية بناء شجرة التحليل النحوي المجردة لبرنامج. رسميًا، ينتج عنها رسم بياني <span class="math inline">\(\mathcal{G}(V, f, E)\)</span> حيث <span class="math inline">\(V = V_\textsc{var} \cup V_\textsc{cst} \cup V_\textsc{val} \cup V_\textsc{ope} \cup V_\textsc{mod}\)</span>، و<span class="math inline">\(f = f_\textsc{var} \cup f_\textsc{cst} \cup f_\textsc{val} \cup f_\textsc{ope} \cup f_\textsc{mod}\)</span>، و<span class="math inline">\(E\)</span> هي الحواف التي تربط الرؤوس وتعكس العلاقات في القيد.</p>
<h1 id="ترميز-المشكلة">ترميز المشكلة</h1>
<p>يمثّل الترميز مثيلًا لمشكلة توافقية باعتباره مثالًا تشغيليًا. هناك <span class="nodecor">3</span> رؤوس للقيم (باللون الأخضر) ورأسان للمتغيرات (باللون الأحمر). بما أن <span class="nodecor"><span class="math inline">\(x_1\)</span></span> يمكنه أن يأخذ القيم <span class="nodecor">1</span> و<span class="nodecor">2</span> في نطاقه، فهو متصل بحافتين، وكذلك <span class="nodecor"><span class="math inline">\(x_2\)</span></span>. هناك <span class="nodecor">2</span> رؤوس قيد (باللون الأزرق)، واحدة لعدم المساواة (<span class="nodecor"><span class="math inline">\(\leq\)</span></span>) وأخرى لقيد الجدول (<span class="nodecor"><span class="math inline">\(\textsf{ext}\)</span></span>). توضح المنطقة الرمادية القيد <span class="nodecor"><span class="math inline">\(3x_1 \leq 4x_2\)</span></span> مع العاملين (باللون البرتقالي) وعمليتي الضرب: الأولى (<span class="nodecor"><span class="math inline">\(\times\)</span></span> بميزة <span class="nodecor">3</span>) لـ<span class="nodecor"><span class="math inline">\(x_1\)</span></span> على الجانب الأيمن (<span class="nodecor"><span class="math inline">\(\textsf{rhs}\)</span></span>)، والثانية (<span class="nodecor"><span class="math inline">\(\times\)</span></span> بميزة <span class="nodecor">4</span>) لـ<span class="nodecor"><span class="math inline">\(x_2\)</span></span> على الجانب الأيسر (<span class="nodecor"><span class="math inline">\(\textsf{lhs}\)</span></span>). يوضح المشغّلان <span class="nodecor"><span class="math inline">\(\textsf{rhs}\)</span></span> و<span class="nodecor"><span class="math inline">\(\textsf{lhs}\)</span></span> جانبي المعادلة، وهو أمر ضروري للتمييز بين <span class="nodecor"><span class="math inline">\(3x_1 \leq 4x_2\)</span></span> و<span class="nodecor"><span class="math inline">\(3x_1 \geq 4x_2\)</span></span>، ويرتبط بالقيد المناسب. يتم التعبير عن قيد الجدول <span class="nodecor"><span class="math inline">\(\textsc{table}([x_1,x_2],[(1,2),(2,3)])\)</span></span> بطريقة مماثلة عبر زوجين <span class="nodecor"><span class="math inline">\(t_1\)</span></span> و<span class="nodecor"><span class="math inline">\(t_2\)</span></span>. أخيرًا، يتصل رأس النموذج (باللون الأصفر) بالقيدين وبالمتغير <span class="nodecor"><span class="math inline">\(x_1\)</span></span> كجزء من دالة الهدف.</p>
<p>ملاحظة ختامية: يمكن استخدام هذا الترميز لتمثيل أي مثيل لمشكلة توافقية بطريقة فريدة. يتطلب ذلك تطوير محلل لكل قيد يحدد كيفية تفكيكه إلى مشغلات ومتغيرات. ندعم حاليًا جميع القيود المدرجة في نص XCSP3-core (<span class="nodecor">Boussemart_Lecoutre_Audemard_Piette_2022</span>) والمستخدمة في مسارات الحل المصغر لمسابقة <span class="nodecor">XCSP-2023</span>: المساواة الثنائية، الجدول، الجدول السلبي، الجدول القصير، العنصر، والمجموع. يحتوي مستودعنا على الوثائق اللازمة لبناء الرسم البياني لأي مثيل بصيغة XCSP3-core ووصف جميع الميزات المدعومة.</p>
<h1 id="sec:gnn">التعلم من الترميز باستخدام شبكة عصبية بيانية</h1>
<p>لتحقيق الخطوة التالية ولتعلم هذا التمثيل، صممنا بنية <em>شبكة عصبية بيانية</em> مخصصة للاستفادة من هذا الترميز. الشبكة العصبية البيانية هي بنية متخصصة لحساب التمثيل الكامن (التضمين) لكل عقدة في الرسم البياني المعطى (<span class="nodecor">Scarselli_Gori_Tsoi_Hagenbuchner_Monfardini_2009</span>) من خلال تجميع المعلومات من العقد المجاورة بشكل تكراري. تُسمى كل خطوة تجميع بطبقة وتتضمن أوزانًا قابلة للتعلم، وهناك عدة طرق للتجميع معروفة في الأدبيات (<span class="nodecor">li2016gated</span>, <span class="nodecor">monti2017geometric</span>, <span class="nodecor">velivckovicgraph</span>). النموذج قابل للتفاضل ويمكن تدريبه باستخدام الانحدار التدريجي.</p>
<p>...</p>
<h1 id="sec:exp">التجارب</h1>
<p>يقيم هذا القسم منهجيتنا على أربع مهمات توافقية: <span style="font-variant: small-caps;">SAT</span>، <span style="font-variant: small-caps;">COL</span>، <span style="font-variant: small-caps;">Knap</span>، و<span style="font-variant: small-caps;">TSP</span> (نموذجَي <span style="font-variant: small-caps;">TSP-Ext</span> و<span style="font-variant: small-caps;">TSP-Elem</span>). درّبنا النماذج على نسخ قرارية من المشكلات، مستوضحين ما إذا كان هناك حل بتكلفة أقل من الهدف <span class="math inline">\(k\)</span>؛ وعند عدم وجود دالة هدف تصبح مسألة إشباع بسيطة (<span style="font-variant: small-caps;">SAT</span>). قارنا منهجيتنا مع الهياكل المعمارية المخصصة لكل مشكلة والرسم الثلاثي الطبقات لمارتي وآخرين (2023) (<span class="nodecor">Marty_François_Tessier_Gauthier_Rousseau_Cappart_2023</span>). اعتمدنا الدقة في التنبؤ بوجود الحل مقياسًا للتقييم، واتبعنا البروتوكولات والتفاصيل التنفيذية المنشورة.</p>
<dl>
<dt>مشكلة الإشباع البولياني</dt>
<dd><p>استُخدم المولد العشوائي لـ<span class="nodecor">Selsam et al</span>. (2018) (<span class="nodecor">Selsam2018</span>) لتوليد أزواج من نماذج <span style="font-variant: small-caps;">SAT</span> ذات <span class="math inline">\(n\)</span> متغيرات بإضافة شروط عشوائية حتى تصبح المسألة غير قابلة للإشباع، ثم يُقلّب إشارة إحدى المتغيرات لجعلها قابلة للإشباع. تضمّ شروط المولد في المتوسط نحو <span class="nodecor">8</span> أحكام، وضمّنا كلًا من التوزيعين القابل وغير القابل للإشباع في مجموعة البيانات. أنشأنا مجموعة تدريب مكوّنة من <span class="nodecor">3,980,000</span> نموذج ومجموعة تحقق من <span class="nodecor">20,000</span>.</p>
</dd>
<dt>مشكلة البائع المتجول</dt>
<dd><p>استُخدم المولد العشوائي لـ<span class="nodecor">Prates et al</span>. (2018) (<span class="nodecor">Prates_Avelar_Lemos_Lamb_Vardi_2018</span>). يتكوّن الجيل من: (1) توزيع <span class="math inline">\(n\)</span> نقاط عشوائية في مربع <span class="math inline">\((\sqrt{2}/2 \times \sqrt{2}/2)\)</span>، (2) حساب مصفوفة المسافات الإقليدية، و(3) حل المثيل بالمحلل Concorde (<span class="nodecor">applegate2006concorde</span>) للحصول على التكلفة الأمثل <span class="math inline">\(C^*\)</span>. ثم أنتجنا نموذجين: أحدهما قابل بالهدف <span class="nodecor">1.02</span>×<span class="math inline">\(C^*\)</span>، والآخر غير قابل بالهدف <span class="nodecor">0.98</span>×<span class="math inline">\(C^*\)</span>. بنينا نموذجَي <span style="font-variant: small-caps;">TSP</span>: الأول بقيد التمديد (<span style="font-variant: small-caps;">TSP-Ext</span>)، والثاني بقيد العنصر (<span style="font-variant: small-caps;">TSP-Elem</span>) لدراسة أثر النموذج على الترميز البياني والأداء. أنشأنا <span class="nodecor">850,000</span> نموذجًا للتدريب و<span class="nodecor">50,000</span> للتحقق.</p>
</dd>
<dt>تلوين الرسم البياني</dt>
<dd><p>اتبعنا مولّد <span class="nodecor">lemos2019graph</span> لإنشاء رسومات من <span class="nodecor">40</span> إلى <span class="nodecor">60</span> رأسًا. لكل رسم نضيف حافة واحدة لتغيير قابلية التلوين بـ<span class="math inline">\(k\)</span>، فنجمع نموذجَين: قيمة مثلى = <span class="math inline">\(k\)</span> وأخرى أعلى. يستفيد الترميز من قيد <span class="math inline">\(\neq\)</span>. استخدمنا <span class="nodecor">140,000</span> نموذجًا للتدريب و<span class="nodecor">10,000</span> للتحقق.</p>
</dd>
<dt>مشكلة الحقيبة</dt>
<dd><p>أنشأنا نماذجًا تحتوي من <span class="nodecor">20</span> إلى <span class="nodecor">40</span> عنصرًا وحللناها لإيجاد القيمة المثلى <span class="math inline">\(V^*\)</span>. ثم أنتجنا نموذجين: أحدهما قابل بالهدف <span class="nodecor">1.02</span>×<span class="math inline">\(V^*\)</span>، والآخر غير قابل بالهدف <span class="nodecor">0.98</span>×<span class="math inline">\(V^*\)</span>. يستفيد الترميز من قيد <span style="font-variant: small-caps;">sum</span>. استخدمنا <span class="nodecor">950,000</span> نموذجًا للتدريب و<span class="nodecor">50,000</span> للتحقق.</p>
</dd>
<dt>تفاصيل التنفيذ</dt>
<dd><p>درّبنا جميع النماذج باستخدام PyTorch (<span class="nodecor">paszke2019pytorch</span>) وPyTorch-Geometric (<span class="nodecor">fey2019fast</span>) على بطاقة Nvidia V100 بسعة <span class="nodecor">32</span> GB لمدة تصل إلى <span class="nodecor">4</span> أيام أو حتى التقارب. اخترنا النموذج الأفضل على مجموعة التحقق. لضمان عدالة المقارنة بين الهياكل المعمارية الخاصة والعامة، استخدمنا بطاقة واحدة وضبّطنا عدد الوحدات الخفية في MLP وLSTM. وللنماذج المخصصة، احتفظنا بنفس المعايير الفائقة في منشوراتها الأصلية. درّبنا النماذج بمُحسّن Adam (<span class="nodecor">KingmaB14</span>) مع جدول معدل التعلم وتخميد وزن <span class="nodecor"><span class="math inline">\(10^{-8}\)</span></span>. يمكن العثور على كافة المعايير الفائقة في الكود المرفق. جميع نماذجنا معبر عنها بصيغة <span style="font-variant: small-caps;">XCSP3</span>.</p>
</dd>
</dl>
<p>قمنا بتنفيذ محلل لبناء الرسم البياني حسب هذا الترميز. شيفرتنا ونماذجنا المدربة متاحة للجمهور.</p>
<h2 id="النتائج-دقة-المناهج">النتائج: دقة المناهج</h2>
<p>يوضح الجدول [table:main-results] الدقة في التنبؤ بالإجابة الصحيحة على مجموعة التحقق لكل مشكلة وخط أساس. من المثير للاهتمام أن منهجنا يحقق أداءً مماثلًا للهياكل المعمارية المخصصة لكل مشكلة، مما يدلّ على إمكانية استخدامه مباشرة دون الحاجة لتصميم هيكل جديد مخصص. على النقيض، تراجع أداء منهج <span class="nodecor">Marty_François_Tessier_Gauthier_Rousseau_Cappart_2023</span> في جميع المشكلات باستثناء تلوين الرسم البياني، لأن هذا التمثيل لا يحافظ على البنية التركيبية للقيود المعقدة.</p>
<p>بينما يحقق <span style="font-variant: small-caps;">TSP-Elem</span> نتائج قريبة من النموذج المخصص لـTSP، يعاني <span style="font-variant: small-caps;">TSP-Ext</span> من أداء أقل بوضوح، مما يبيّن أهمية اختيار نموذج إدخال مناسب للترميز. على سبيل المثال، ينتج <span style="font-variant: small-caps;">TSP-Elem</span> ترميزًا بحجم <span class="math inline">\(1841\)</span> رأسًا و<span class="math inline">\(13042\)</span> حافة، بينما يولّد <span style="font-variant: small-caps;">TSP-Ext</span> رسمًا بيانيًا مكوّنًا من <span class="math inline">\(5661\)</span> رأسًا و<span class="math inline">\(28322\)</span> حافة لنفس المثيل، مما يصعّب التدريب بسبب الحجم الأكبر.</p>
<h2 id="تحليل-التعميم-على-نماذج-أكبر">تحليل: التعميم على نماذج أكبر</h2>
<p>يوضح الشكل <span class="nodecor">fig:generalization</span> قدرة التعميم لنموذجنا، دون إعادة تدريب، على نماذج جديدة من <span class="nodecor">60</span> و<span class="nodecor">80</span> و<span class="nodecor">100</span> متغير (5000 نموذج لكل حجم). نلاحظ أن تمثيلنا العام يوفر تعميمًا أفضل من الهياكل المعمارية المخصصة لمشكلتَي <span class="nodecor">SAT</span> و<span class="nodecor">TSP</span>. بشكل لافت، يقدم <span class="nodecor">TSP-Elem</span> تعميمًا أفضل بكثير من <span class="nodecor">TSP-Ext</span>، مما يؤكد أثر نموذج الإدخال وحجم الرسم البياني. كذلك تبدو قدرة التعميم القوية للنموذج المخصص لمشكلة الحقيبة نابعةً أوليًا من دالة تجميع في GNN تعتمد على مجموع موزون. دراسة الأسباب الجذرية لهذا التعلم المتعمم موضوع بحث مستقبلي.</p>
<h2 id="المناقشة-القيود-والتحديات">المناقشة: القيود والتحديات</h2>
<p>على الرغم من النتائج المشجعة، هنالك بعض التحديات. أولًا، زمن التدريب طويل حتى على حالات صغيرة نسبيًا، ويرجع ذلك جزئيًا إلى حجم الرسومات الناتجة. هذا يفتح الباب لطرق ضغط خاصة تقلّص حجم الترميز دون فقدان المعلومات، مثل قيود <span class="nodecor">smartTable</span> (<span class="nodecor">mairy2015smart</span>). كما يبرز أهمية نموذج إدخال ينتج تضمينًا أصغر (مثل <span class="nodecor">TSP-Elem</span> مقارنة بـ<span class="nodecor">TSP-Ext</span>). ثانيًا، اقتصرت المهمة الحالية على حل النسخ القرارِية من المشكلات بشكل من البداية إلى النهاية. وسيكون الدمج مع إجراءات حل كاملة، كما اقترح <span class="nodecor">Gasse_Chetelat_Ferroni_Charlin_Lodi_2019</span> للبرمجة المختلطة الثنائية و<span class="nodecor">cappart2021combining</span> للبرمجة بالقيود، خطوة مهمة. أخيرًا، يبقى اختبار تعميم النموذج المدرب على مشكلة معينة (مثل <span class="nodecor">TSP</span>) على نسخة مشابهة (مثل <span class="nodecor">TSP</span> مع نوافذ زمنية) محورًا مثيرًا للاستكشاف.</p>
<h1 id="الخلاصة-والآفاق">الخلاصة والآفاق</h1>
<p>قدم هذا البحث نموذجًا أوليًا لإجراء عام لترميز حالات المشكلات التركيبية إلى رسم بياني مناسب للتعلم. الترميز المقترح حقْنِيّ، بحيث يشير كل تمثيل إلى مثيل فريد للمشكلة. إلى جانب ذلك، اقترحنا بنية شبكة عصبية بيانية للتعلم من هذا التمثيل. أظهرت النتائج التجريبية أن منهجنا يحقق أداءً مقاربًا للهياكل المعمارية المخصصة دون الحاجة لتصميم يدوي لممثل خاص. جميع قيود مسابقة المسار المصغر لعام <span class="nodecor">2023</span> مدعومة حاليًا؛ وإضافة قيود جديدة تتطلب فقط تنفيذ محلل جديد. تشمل خطواتنا القادمة تطبيق النهج على مشكلات أكبر وأكثر تعقيدًا وعلى مهام تركيبية أخرى (مثل تعلم الاستدلالات الفرعية).</p>
<h1 id="الشكر-والتقدير" class="unnumbered">الشكر والتقدير</h1>
<p>تم تمويل هذا البحث بشكل رئيسي بفضل منحة اكتشاف <span class="nodecor">NSERC</span> (كندا) التي يحملها كوينتن كابارت. كما تلقى تمويلًا من برنامج الاتحاد الأوروبي للبحث والابتكار <span class="nodecor">Horizon 2020</span> بموجب اتفاقية منحة رقم <span class="nodecor">101070149</span>، مشروع <span class="nodecor">Tuples</span>.</p>
</body>
</html>