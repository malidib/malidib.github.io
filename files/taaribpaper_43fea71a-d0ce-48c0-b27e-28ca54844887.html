<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Léo Boisvert">
  <meta name="author" content="Hélène Verhaeghe">
  <meta name="author" content="Quentin Cappart">
  <title>نحو تمثيل عام لمشكلات التوليف للمقاربات المبنية على التعلم</title>
  <style type="text/css">code{white-space: pre;}</style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <style>body { direction: rtl; font-size: 22px; }</style>
</head>
<body>
<header>
<h1 class="title">نحو تمثيل عام لمشكلات التوليف للمقاربات المبنية على التعلم</h1>
<p class="author"><span class="nodecor">Léo Boisvert</span></p>
<p class="author"><span class="nodecor">Hélène Verhaeghe</span></p>
<p class="author"><span class="nodecor">Quentin Cappart</span></p>
</header>
<h1 id="ملخص">مُلَخَّص</h1>
<p>في السنوات الأخيرة، كان هناك اهتمام متزايد باستخدام المقاربات المبنية على التعلم لحل مشكلات التوليف، سواء بطريقة نهائية أو بالتعاون مع خوارزميات التحسين التقليدية. في كلا السيناريوهين، يكمن التحدي في ترميز مشكلات التوليف المستهدفة إلى هيكل متوافق مع خوارزمية التعلم. لقد اقترحت العديد من الأعمال السابقة تمثيلات محددة للمشكلة، غالبًا على شكل رسم بياني، للاستفادة من مزايا <em>الشبكات العصبية البيانية</em>. ومع ذلك، تفتقر هذه المقاربات إلى العمومية، حيث لا يمكن نقل التمثيل بسهولة من مشكلة توليفية إلى أخرى. على الرغم من أن بعض المحاولات قد أُجريت لسد هذه الفجوة، إلا أنها لا تزال تقدم عمومية جزئية فقط. استجابة لهذا التحدي، يدعو هذا البحث إلى التقدم نحو تمثيل عام كامل لمشكلات التوليف للمقاربات المبنية على التعلم. النهج الذي نقترحه يتضمن بناء رسم بياني عن طريق تحليل أي قيد من مشكلة التوليف إلى شجرة تحليل نحوي مجردة والتعبير عن العلاقات (مثل متغير مشترك في قيد) من خلال الحواف. علاوة على ذلك، نقدم بنية شبكة عصبية بيانية قادرة على التعلم بكفاءة من هذا التمثيل. الأداة المقدمة تعمل على مشكلات التوليف المعبر عنها بتنسيق <span class="nodecor">XCSP3</span>، معالجة جميع القيود المتاحة في مسابقة المسار المصغر لعام <span class="nodecor">2023</span>. تظهر النتائج التجريبية على أربع مشكلات توليفية أن بنيتنا تحقق أداءً مماثلاً للهندسات المخصصة مع الحفاظ على العمومية. تتوفر شيفرتنا ونماذجنا المدربة للجمهور على <a href="https://github.com/corail-research/learning-generic-csp" class="uri">https://github.com/corail-research/learning-generic-csp</a>.</p>
<h1 id="مقدمة">مُقَدِّمَة</h1>
<p>لقد جذبت <span class="nodecor">التحسين التوافقي</span> انتباه علماء الحاسوب منذ نشأة هذا المجال. وقد كانت المشكلات التوافقية، مثل <span class="nodecor">مشكلة البائع المتجول</span> أو <span class="nodecor">الإشباع البولياني</span>، محور عقود من البحث في مجتمع علوم الحاسوب. يمكننا الآن حل مشكلات كبيرة من هذه الأنواع بكفاءة باستخدام الطرق الدقيقة (<span class="nodecor">Applegate2009</span>) والإجراءات التقريبية (<span class="nodecor">36b9628e7a874d208624584d8a470985</span>). الإجراءات التقريبية هي إجراءات مصممة يدويًا تجسد معرفة وحدس الخبراء حول بنية المشكلات التي يتم تطبيقها عليها. بينما حققت الإجراءات التقريبية نجاحًا وتطبيقات في حل المشكلات التوافقية إما كعملية حل مباشرة أو مدمجة في إجراء بحث، فقد جذب ارتفاع <span class="nodecor">التعلم العميق</span> في العديد من المجالات المختلفة (<span class="nodecor">Bahdanau_Cho_Bengio_2016</span>, <span class="nodecor">brown2020language</span>, <span class="nodecor">Krizhevsky_Sutskever_Hinton_2012</span>, <span class="nodecor">mnih2015human</span>) انتباه الباحثين (<span class="nodecor">Prouvost_2020</span>). من بين هياكل <span class="nodecor">التعلم العميق</span>، <em>الشبكات العصبية البيانية</em> (<span class="nodecor">GNNs</span>) (<span class="nodecor">Scarselli_Gori_Tsoi_Hagenbuchner_Monfardini_2009</span>) أثبتت أنها أداة قوية ومرنة لحل المشكلات التوافقية. ومع ذلك، كما حدد <span class="nodecor">Cappart <span class="nodecor">et al</span>.</span> (2023) (<span class="nodecor">cappart2021combinatorial</span>), لا يزال من الصعب دمج <span class="nodecor">GNN</span> و<span class="nodecor">التعلم الآلي</span> في عمليات الحل القائمة للممارسين. أحد الأسباب هو أنه يجب تصميم وتدريب بنية مخصصة لكل مشكلة توافقية. بالإضافة إلى الموارد الحاسوبية المكلفة المحتملة للتدريب، هذا يتطلب أيضًا وجود مجموعة تدريب كبيرة وموصوفة.</p>
<p>كان بناء تمثيل بياني محدد للمشكلة هو الخيار المفضل لمعظم النهج ذات الصلة، مثل <span class="nodecor">NeuroSAT</span> (<span class="nodecor">Selsam2018</span>) الذي يستفيد من ترميز لصيغ <span class="nodecor">SAT</span>، أو النهج المرتبطة ارتباطًا وثيقًا بـ<span class="nodecor">مشكلة البائع المتجول</span> (<span class="nodecor">Prates_Avelar_Lemos_Lamb_Vardi_2018</span>, <span class="nodecor">joshi2022learning</span>). تعاني هذه النهج من نقص في العمومية حيث لا يمكن تصدير البنية ببساطة من مشكلة توافقية إلى أخرى (على سبيل المثال، لا يمكن استخدام التمثيل في <span class="nodecor">NeuroSAT</span> لترميز حالة من <span class="nodecor">مشكلة البائع المتجول</span>). تم تحقيق بعض المحاولات لسد هذه الفجوة، ولكنها لا تزال توفر فقط عمومية جزئية. على سبيل المثال، اقترح <span class="nodecor">Gasse <span class="nodecor">et al</span>.</span> (2019) (<span class="nodecor">Gasse_Chetelat_Ferroni_Charlin_Lodi_2019</span>) رسمًا بيانيًا ثنائي الأطراف يربط بين المتغيرات والقيود عندما يكون المتغير مشاركًا في قيد معين. ومع ذلك، فإن هذا النهج يشفر فقط البرامج الصحيحة المختلطة الثنائية. لاحقًا، قدم <span class="nodecor">Chalumeau <span class="nodecor">et al</span>.</span> (2021) (<span class="nodecor">chalumeau2021seapearl</span>) رسمًا بيانيًا ثلاثي الأطراف حيث المتغيرات والقيم والقيود هي أنواع محددة من الرؤوس. يفتقر هذا النهج أيضًا إلى العمومية حيث يتطلب إعادة التدريب عندما يتغير عدد المتغيرات. حتى حد علمنا، تم تحقيق محاولة أخرى في هذا الاتجاه بواسطة <span class="nodecor">Marty <span class="nodecor">et al</span>.</span> (2023) (<span class="nodecor">Marty_François_Tessier_Gauthier_Rousseau_Cappart_2023</span>) الذين استفادوا من رسم بياني ثلاثي الأطراف يسمح بتزيين كل نوع رأس بميزات مخصصة. على الرغم من أن أي مشكلة توافقية يمكن نظريًا أن تُشفر بهذا الإطار، فإن بعض المعلومات تضيع مع الترميز. على سبيل المثال، لم يكن من الواضح كيف يمكن التمييز بين القيد <span class="math inline">\(3x_1 \leq 4x_2\)</span>، والقيد <span class="math inline">\(2x_1 \leq 5x_2\)</span>. من ناحية، يمكن تمثيل كلا القيدين كـ<em>عدم مساواة</em>، ولكننا نفقد معلومات حول معاملات المتغيرات. من ناحية أخرى، يمكن تشفير كلا القيدين كعلاقتين متميزتين، ولكن في هذه الحالة، نفقد حقيقة أن لدينا عدم مساواة في كلتا الحالتين. بشكل أكثر رسمية، كانت وظيفة التشفير الخاصة بهم ليست <em>حقنية</em>. يمكن أن يكون لحالات مختلفة نفس التشفير دون خيار للتمييز بينها. بالإضافة إلى ذلك، استهدفت التجارب المقترحة فقط مشكلات نسبياً نقية (<em>المجموعة المستقلة القصوى</em>، <em>القطع الأقصى</em>، و<em>تلوين الرسم</em>). تلاحظ قيود مماثلة في نهج <span class="nodecor">Tönshoff <span class="nodecor">et al</span>.</span> (2022) (<span class="nodecor">Tönshoff_Kisin_Lindner_Grohe_2022</span>).</p>
<p>استنادًا إلى هذا السياق، يتقدم هذا البحث نحو تمثيل عام تمامًا للمشكلات التوافقية للنهج المستندة إلى التعلم. فكرتنا الأساسية هي تفكيك أي قيد من حالة المشكلة كـ<em>شجرة بناء نحوي مجردة</em> وربط العناصر المماثلة (على سبيل المثال، نفس المتغيرات أو القيود) من خلال حافة. ثم، نقدم بنية <span class="nodecor">GNN</span> قادرة على استغلال هذا الرسم. لإظهار العمومية لهذا النهج، تعمل بنيتنا مباشرة على الحالات المعبر عنها بتنسيق <span class="nodecor"><span style="font-variant: small-caps;">XCSP3</span></span> (<span class="nodecor">Boussemart_Lecoutre_Audemard_Piette_2022</span>) ويمكنها التعامل مع جميع القيود المتاحة في مسابقة المسار المصغر لعام <span class="nodecor">2023</span>. تُجرى التجارب على أربع مشكلات (تتميز بالقيود القياسية والعالمية مثل <span class="nodecor"><span style="font-variant: small-caps;">allDifferent</span></span> (<span class="nodecor">regin1994filtering</span>), <span class="nodecor"><span style="font-variant: small-caps;">table</span></span> (<span class="nodecor">demeulenaere2016compact</span>), <span class="nodecor"><span style="font-variant: small-caps;">negativeTable</span></span> (<span class="nodecor">verhaeghe2017extending</span>), <span class="nodecor"><span style="font-variant: small-caps;">element</span></span> و<span class="nodecor"><span style="font-variant: small-caps;">sum</span></span>) وتهدف إلى التنبؤ بالإشباع لنسخ القرار من المشكلات التوافقية. تظهر النتائج أن بنيتنا العامة تقدم أداءً قريبًا من هندسات المشكلات المحددة وتتفوّق على الرسم البياني الثلاثي الأطراف لـ<span class="nodecor">Marty <span class="nodecor">et al</span>.</span> (2023) (<span class="nodecor">Marty_François_Tessier_Gauthier_Rousseau_Cappart_2023</span>).</p>
<h1 id="ترميز-مثاليات-المشكلات-التوافقيه-كرسم-بياني">ترميز مثيلات المشكلات التوافقية كرسم بياني</h1>
<p>رسمياً، يُعرّف مثيل المشكلة التوافقية <span class="math inline">\(\mathcal{P}\)</span> على أنه رباعي <span class="math inline">\(\langle X, D(X), C, O \rangle\)</span>، حيث <span class="math inline">\(X\)</span> هي مجموعة المتغيرات، <span class="math inline">\(D(X)\)</span> هي مجموعة النطاقات، <span class="math inline">\(C\)</span> هي مجموعة القيود، و<span class="math inline">\(O\)</span> (<span class="math inline">\(X \to \mathbb{R}\)</span>) هي دالة الهدف. الحل الصالح هو تعيين كل متغير إلى قيمة من نطاقه بحيث يتم تلبية كل قيد. الحل الأمثل هو حل صالح بحيث لا يوجد حل آخر يحقق قيمة أفضل للهدف. هدفنا هو بناء دالة <span class="math inline">\(\Phi: \langle X, D(X), C, O \rangle \mapsto \mathcal{G}(V,f,E)\)</span>، حيث <span class="math inline">\(\mathcal{G}\)</span> هو رسم بياني و<span class="math inline">\(V\)</span>، <span class="math inline">\(f\)</span>، <span class="math inline">\(E\)</span> هي مجموعات الرؤوس، ميزات الرؤوس ومجموعات الحواف، على التوالي. نريد أن تكون هذه الدالة <em>حقنية</em>، أي أن الترميز يشير إلى مثيل مشكلة توافقية واحدة فقط. نقترح القيام بذلك من خلال تقديم ترميز يتكون من رسم بياني متجانس وغير موجه يتميز بخمسة أنواع من الرؤوس: <em>المتغيرات</em> (<span class="math inline">\(\textsc{var}\)</span>)، <em>القيود</em> (<span class="math inline">\(\textsc{cst}\)</span>)، <em>القيم</em> (<span class="math inline">\(\textsc{val}\)</span>)، <em>العوامل</em> (<span class="math inline">\(\textsc{ope}\)</span>)، و<em>النموذج</em> (<span class="math inline">\(\textsc{mod}\)</span>). الفكرة هي تقسيم كل قيد إلى سلسلة من العمليات الأولية، لدمج الرؤوس التي تمثل نفس المتغير أو القيمة، وربط جميع العلاقات معًا. هذه العملية تشبه بناء شجرة التحليل النحوي المجردة لبرنامج. من الناحية الرسمية، يعطي الترميز رسمًا بيانيًا <span class="math inline">\(\mathcal{G}(V, f, E)\)</span> حيث <span class="math inline">\(V = V_\textsc{var} \cup V_\textsc{cst} \cup V_\textsc{val} 
\cup V_\textsc{ope} \cup V_\textsc{mod}\)</span> هي مجموعة تحتوي على الأنواع الخمسة من الرؤوس، <span class="math inline">\(f = f_\textsc{var} \cup f_\textsc{cst} \cup f_\textsc{val} \cup  
f_\textsc{ope} \cup f_\textsc{mod}\)</span> هي مجموعة الميزات المحددة المرتبطة بكل رأس، و<span class="math inline">\(E\)</span> هي مجموعة الحواف التي تربط الرؤوس. يُعرّف كل نوع على النحو التالي.</p>
<h1 id="ترميز-المشكلة">ترميز المشكلة</h1>
<p>يمثل الترميز مثيلًا لمشكلة توافقية كمثال تشغيلي. هناك <span class="nodecor">3</span> رؤوس قيمة موضحة (باللون الأخضر) و<span class="nodecor">2</span> رؤوس متغيرة (باللون الأحمر). بما أن <span class="nodecor"><span class="math inline">\(x_1\)</span></span> يحتوي على القيم <span class="nodecor">1</span> و<span class="nodecor">2</span> في نطاقه، فهي متصلة بحافة، وكذلك نطاق <span class="nodecor"><span class="math inline">\(x_2\)</span></span>. هناك <span class="nodecor">2</span> رؤوس قيد (باللون الأزرق)، واحدة لعدم المساواة (<span class="nodecor"><span class="math inline">\(\leq\)</span></span>) وواحدة لقيد الجدول (<span class="nodecor"><span class="math inline">\(\textsf{ext}\)</span></span>). توضح المنطقة الرمادية في الشكل القيد <span class="nodecor"><span class="math inline">\(3x_1 \leq 4x_2\)</span></span>، المميز بالمشغلين (باللون البرتقالي) وتظهر عملية الضرب (<span class="nodecor"><span class="math inline">\(\times\)</span></span>، بميزة <span class="nodecor">3</span>) لـ<span class="nodecor"><span class="math inline">\(x_1\)</span></span> على الجانب الأيمن (<span class="nodecor"><span class="math inline">\(\textsf{rhs}\)</span></span>) وآخر (<span class="nodecor"><span class="math inline">\(\times\)</span></span>، بميزة <span class="nodecor">4</span>) لـ<span class="nodecor"><span class="math inline">\(x_2\)</span></span> على الجانب الأيسر (<span class="nodecor"><span class="math inline">\(\textsf{lhs}\)</span></span>). يوضح المشغلان <span class="nodecor"><span class="math inline">\(\textsf{rhs}\)</span></span> و<span class="nodecor"><span class="math inline">\(\textsf{lhs}\)</span></span> جانبي المعادلة، وهو أمر ضروري للتمييز بين <span class="nodecor"><span class="math inline">\(3x_1 \leq 4x_2\)</span></span> و<span class="nodecor"><span class="math inline">\(3x_1 \geq 4x_2\)</span></span>، ويرتبط بالقيد المناسب (على سبيل المثال، عدم المساواة <span class="nodecor"><span class="math inline">\(\leq\)</span></span>). يتم التعبير عن قيد الجدول <span class="nodecor"><span class="math inline">\(\textsc{table}([x_1,x_2],[(1,2),(2,3)])\)</span></span> بطريقة مماثلة. يتضمن ذلك زوجين <span class="nodecor"><span class="math inline">\(t_1\)</span></span> و<span class="nodecor"><span class="math inline">\(t_2\)</span></span>. أخيرًا، يتصل رأس النموذج (باللون الأصفر) بالقيدين، وبالمتغير <span class="nodecor"><span class="math inline">\(x_1\)</span></span>، حيث إنه جزء من دالة الهدف.</p>
<p>كملاحظة ختامية، يمكن استخدام هذا الترميز لتمثيل أي مثيل لمشكلة توافقية بطريقة فريدة. للقيام بذلك، يجب تنفيذ محلل لكل قيد، يصف كيفية تقسيم القيد مع المشغلين والمتغيرات المعنية. نحن ندعم حاليًا جميع القيود الموضحة في تنسيق نمذجة <span class="nodecor">XCSP3-core</span> (<span class="nodecor">Boussemart_Lecoutre_Audemard_Piette_2022</span>) والمستخدمة في مسارات الحل الصغيرة لمسابقة <span class="nodecor">XCSP-2023</span>: المساواة الثنائية، الجدول، الجدول السلبي، الجدول القصير، العنصر والمجموع. يحتوي مستودعنا على الوثائق المطلوبة لبناء رسم بياني من مثيل في تنسيق <span class="nodecor">XCSP3-core</span> مع وصف لجميع الميزات المعتمدة.</p>
<h1 id="sec:gnn">التعلم من الترميز باستخدام شبكة عصبية بيانية</h1>
<p>لتحقيق الخطوة التالية و<em>التعلم</em> من هذا التمثيل، قمنا بتصميم بنية <em>شبكة عصبية بيانية</em> مخصصة للاستفادة من هذا الترميز. شبكة عصبية بيانية هي بنية عصبية متخصصة مصممة لحساب تمثيل كامن (يعرف بـ<em>التضمين</em>) لكل عقدة من الرسم البياني المعطى (<span class="nodecor">Scarselli_Gori_Tsoi_Hagenbuchner_Monfardini_2009</span>). تتضمن هذه العملية تجميع المعلومات من العقد المجاورة بشكل تكراري. يُشار إلى كل خطوة تجميع بـ<em>طبقة</em> من شبكة عصبية بيانية وتتضمن أوزانًا قابلة للتعلم. هناك طرق مختلفة لأداء هذا التجميع، مما يؤدي إلى متغيرات مختلفة من الشبكات العصبية البيانية موثقة في الأدبيات (<span class="nodecor">li2016gated</span>, <span class="nodecor">monti2017geometric</span>, <span class="nodecor">velivckovicgraph</span>). النموذج قابل للتفاضل ويمكن بعد ذلك تدريبه باستخدام طرق الانحدار التدريجي.</p>
<p>لنفترض أن <span class="math inline">\(\mathcal{G}(V, f, E)\)</span> هو الترميز البياني الذي تم الحصول عليه مسبقًا، وليكن <span class="math inline">\(h^{[i]}_{t,v} \in \mathbb{R}^{p}\)</span> تمثيلاً متجهيًا بأبعاد <span class="math inline">\(p\)</span> لرأس <span class="math inline">\(v \in V_t\)</span> (<span class="math inline">\(t\)</span> يشير إلى نوع رأس من <span class="math inline">\(\mathcal{T} : \{\textsc{var},\textsc{val},\textsc{cst},\textsc{ope},\textsc{mod}\}\)</span>) في التكرار <span class="math inline">\(i \in \{ 0, \ldots, I\}\)</span>. عملية الاستدلال لشبكة عصبية بيانية تتمثل في حساب التمثيلات التالية (<span class="math inline">\(h^{[i+1]}_{t,v}\)</span>) من التمثيلات السابقة لكل رأس. يُشار إلى هذه العملية عادةً بـ<em>تمرير الرسالة</em>. أولاً، نضع <span class="math inline">\(h^{[0]}_{t,v}  =  f_{t,v}\)</span> لكل نوع، حيث <span class="math inline">\(f_{t,v}\)</span> هو متجه الميزات المتعلقة برأس <span class="math inline">\(v \in V_{t}\)</span>. ثم يتم الحصول على التمثيلات في كل تكرار باستخدام <span class="math inline">\(\textsc{LayerNorm}\)</span> (<span class="nodecor">ba2016layer</span>) وطبقات LSTM (<span class="nodecor">Hochreiter_Schmidhuber_1997</span>). يتم توضيح العملية بالكامل في الخوارزمية [algo:inference]. أولاً، يتم تعيين التضمين الأولي لكل رأس إلى ميزته (السطر [eql:1]) ويتم تهيئة حالات LSTM الخفية إلى 0 (السطر [eql:2])، كما هو شائع. ثم يتم إجراء <span class="math inline">\(I\)</span> خطوات من تمرير الرسالة (الحلقة الرئيسية). في كل تكرار <span class="math inline">\(i\)</span>، يتم الحصول على <em>رسالة</em> (<span class="math inline">\(\mu^{[i]}_{t_1,v}\)</span>) لكل رأس. يتم الحساب في ثلاث خطوات (السطر [eql:4]): (1) يتم جمع التضمين لكل جار من نوع معين، (2) يتم إدخال القيمة الناتجة إلى شبكة الإدراك المتعدد الطبقات القياسية (<span class="math inline">\(\mathsf{MLP}^{\mathsf{in}}_{t_1,t_2}\)</span>)، لاحظ أن هناك وحدة محددة لكل نوع حافة، (3) يتم دمج الرسائل المتعلقة بكل نوع معًا (<span class="math inline">\(\bigoplus\)</span>) للحصول على الرسالة العامة لكل رأس. الرمز <span class="math inline">\(\mathcal{N}_{t_2}(v)\)</span> يشير إلى مجموعة الجيران لرأس <span class="math inline">\(v\)</span> من النوع <span class="math inline">\(t_2\)</span>. ثم يتم إعطاء النتيجة كمدخلات إلى خلية LSTM (السطر [eql:5]، خلية واحدة لكل نوع) ويتم استخدامها للحصول على التضمين في الطبقة التالية. نلاحظ أن كل LSTM لها حالتها الداخلية (<span class="math inline">\(\gamma^{[i]}_{t,v}\)</span>) محدثة. في نهاية الحلقة، لكل رأس تضمين محدد (<span class="math inline">\(h^{[I]}_{t,v}\)</span>). بعد التكرار الأخير، نحسب الإخراج المعتمد على نوع الرأس من خلال تمرير <span class="math inline">\(h^{[I]}_{t,v}\)</span> من خلال شبكة الإدراك المتعدد الطبقات القياسية <span class="math inline">\(\mathsf{MLP}^{\mathsf{out}}_{t}\)</span> (السطر [eql:6]). ثم يتم توسيط التضمينات الناتجة لجميع العقد (السطر [eql:7]). أخيرًا، يتم استخدام دالة السيجمويد (<span class="math inline">\(\sigma\)</span>) للحصول على إخراج بين 0 و1.</p>
<p><span class="math inline">\(\triangleright\)</span> <strong>Pre:</strong> <span class="math inline">\(\mathcal{G}(V_{\textsc{var}, \textsc{cst},\textsc{val}, 
\textsc{ope},\textsc{mod}}, f_{\textsc{var}, \textsc{cst},\textsc{val}, 
\textsc{ope},\textsc{mod}}, E)\)</span> هو الترميز البياني.</p>
<p><span class="math inline">\(\triangleright\)</span> <strong>Pre:</strong> <span class="math inline">\( \mathcal{T} : \{\textsc{var},\textsc{val},\textsc{cst},\textsc{ope},\textsc{mod}\}\)</span> هي مجموعة <em>أنواع الرؤوس</em>.</p>
<p><span class="math inline">\(\triangleright\)</span> <strong>Pre:</strong> <span class="math inline">\(I\)</span> هو عدد تكرارات شبكة العصبية البيانية.</p>
<p> </p>
<p><span class="math inline">\(h^{[0]}_{t,v} := f_{t,v} ~ ~ ~      \forall  v \in  V_t, \forall  t \in  \mathcal{T}  \)</span> [eql:1]</p>
<p><span class="math inline">\(\gamma^{[0]}_{t,v} := 0 ~ ~ ~ ~ ~  ~ ~  ~     \forall  v \in  V_t,  \forall  t \in  \mathcal{T} \)</span> [eql:2]</p>
<p><span class="math inline">\( \nu_{t,v} :=  \mathsf{MLP}^{\mathsf{out}}_{t} \Big(h^{[I]}_{t,v} \Big) ~ ~ ~    \forall  v \in  V_t, \forall t \in \mathcal{T}\)</span> [eql:6]</p>
<p><span class="math inline">\(\hat{y} := \sigma\Big( \frac{1}{|\mathcal{T}|\times |V|} \sum\limits_{t \in \mathcal{T}} \sum\limits_{v \in V_t} \nu_{t,v}  \Big)\)</span> [eql:7]</p>
<p><span class="math inline">\(\hat{y}\)</span> [eql:8]</p>
<h1 id="sec:exp">التجارب</h1>
<p>يقيم هذا القسم منهجيتنا على المهام التوافقية، مع التركيز على أربعة مشكلات: مشكلة الإشباع البولياني (<span style="font-variant: small-caps;">SAT</span>)، تلوين الرسم البياني (<span style="font-variant: small-caps;">COL</span>)، مشكلة الحقيبة (<span style="font-variant: small-caps;">Knap</span>)، ومشكلة البائع المتجول (<span style="font-variant: small-caps;">TSP</span>) مع نماذج <span style="font-variant: small-caps;">TSP-Ext</span> (قيد الجدول) و<span style="font-variant: small-caps;">TSP-Elem</span> (قيد العنصر). قمنا بتدريب النماذج على النسخة القرارية من المشكلات، متسائلين إذا كانت هناك حلول موجودة بتكاليف أقل من هدف <span class="math inline">\(k\)</span>. عندما لا توجد دالة هدف، لدينا مشكلة إشباع مقيدة بسيطة (مثل <span style="font-variant: small-caps;">SAT</span>). الهدف ليس إيجاد الحل ولكن تحديد وجوده، تماشيًا مع الدراسات الحديثة (<span class="nodecor">Selsam2018</span>, <span class="nodecor">Prates_Avelar_Lemos_Lamb_Vardi_2018</span>, <span class="nodecor">lemos2019graph</span>, <span class="nodecor">Liu_Zhang_Huang_Niu_Ma_Zhang_2020</span>). قارنا منهجيتنا مع الهياكل المعمارية المحددة بالمشكلة والرسم البياني الثلاثي لمارتي وآخرين. (<span class="nodecor">2023</span>) (<span class="nodecor">Marty_François_Tessier_Gauthier_Rousseau_Cappart_2023</span>). للأخير، استخرجنا تمثيل الرسم البياني الخاص بهم واستخدمناه في شبكتنا العصبية البيانية. المقياس التقييمي المعتمد هو الدقة في التنبؤ الصحيح بالإجابة على المشكلة القرارية. تتبع التفاصيل حول البروتوكولات التجريبية وتفاصيل التنفيذ.</p>
<dl>
<dt>مشكلة الإشباع البولياني.</dt>
<dd><p>تم إنشاء النماذج باستخدام المولد العشوائي لسيلسام وآخرين. (<span class="nodecor">2018</span>) (<span class="nodecor">Selsam2018</span>). باختصار، يبني المولد أزواجًا عشوائية من نماذج <span style="font-variant: small-caps;">SAT</span> من <span class="math inline">\(n\)</span> متغيرات بإضافة شروط عشوائية جديدة حتى تصبح المشكلة غير قابلة للإشباع. بمجرد أن تصبح المشكلة غير قابلة للإشباع، يتم تغيير إشارة الحرف الأول من المشكلة، مما يجعلها قابلة للإشباع. في المتوسط، تحتوي الشروط على <span class="nodecor">8</span> حدود. تم تضمين كل من النماذج القابلة للإشباع وغير القابلة للإشباع في مجموعة البيانات. لا يزال باتباع سيلسام وآخرين. (<span class="nodecor">2018</span>)، قمنا ببناء مجموعة بيانات تحتوي على ملايين النماذج التي تحتوي على <span class="nodecor">10</span> إلى <span class="nodecor">40</span> حرفًا. تم أيضًا تقديم الهيكل المعماري المعتمد على <span style="font-variant: small-caps;">SAT</span> في نفس الورقة. استخدمنا مجموعة تدريب بحجم <span class="nodecor">3,980,000</span> ومجموعة تحقق بحجم <span class="nodecor">20,000</span>.</p>
</dd>
<dt>مشكلة البائع المتجول.</dt>
<dd><p>تم إنشاء النماذج باستخدام المولد العشوائي لبراتس وآخرين. (<span class="nodecor">2018</span>) (<span class="nodecor">Prates_Avelar_Lemos_Lamb_Vardi_2018</span>). يتكون الإنشاء من (1) إنشاء <span class="math inline">\(n\)</span> نقاط في مربع <span class="math inline">\((\sqrt{2}/2 \times \sqrt{2}/2)\)</span>، (2) بناء مصفوفة المسافات باستخدام المسافة الإقليدية، و(3) حلها باستخدام محلل كونكورد (<span class="nodecor">applegate2006concorde</span>) للحصول على تكلفة الجولة المثلى <span class="math inline">\(C^*\)</span>. ثم يتم إنشاء نموذجين: واحد قابل للتحقيق وآخر غير قابل للتحقيق بتكاليف هدف <span class="nodecor">1.02</span> <span class="math inline">\(C^*\)</span> و<span class="nodecor">0.98</span> <span class="math inline">\(C^*\)</span>، على التوالي. نبني نموذجين <span style="font-variant: small-caps;">TSP</span>: الأول حيث يتم التعبير عن قيود المسافة بقيد التمديد (<span style="font-variant: small-caps;">TSP-Ext</span>)، والثاني بقيد العنصر (<span style="font-variant: small-caps;">TSP-Elem</span>). الدافع هو تحليل تأثير النموذج على الترميز البياني الناتج والأداء. لا يزال باتباع براتس وآخرين. (<span class="nodecor">2018</span>)، قمنا ببناء مجموعة البيانات بعدد مدن <span class="math inline">\(n\)</span> مأخوذة عشوائيًا من <span class="nodecor">20</span> إلى <span class="nodecor">40</span>. تم أيضًا تقديم الهيكل المعماري المعتمد على <span style="font-variant: small-caps;">TSP</span> في نفس الورقة. استخدمنا مجموعة تدريب بحجم <span class="nodecor">850,000</span> ومجموعة تحقق بحجم <span class="nodecor">50,000</span>.</p>
</dd>
<dt>تلوين الرسم البياني.</dt>
<dd><p>تم إنشاء النماذج باتباع ليموس وآخرين. (<span class="nodecor">2019</span>) (<span class="nodecor">lemos2019graph</span>). يبني هذا المولد رسومات بيانية تحتوي على <span class="nodecor">40</span> إلى <span class="nodecor">60</span> رأسًا. لكل رسم بياني، يتم إضافة حافة واحدة بحيث يتغير <span class="math inline">\(k\)</span>-القابلية للتلوين. تتم إنتاج النماذج في أزواج: واحد حيث القيمة المثلى هي <span class="math inline">\(k\)</span> وآخر حيث هي أعلى. يستفيد ترميزنا من نموذج تلوين الرسم البياني القياسي الذي يتميز بقيود المساواة الثنائية (<span class="math inline">\(\neq\)</span>). تم أيضًا تقديم الهيكل المعماري المعتمد على <span style="font-variant: small-caps;">Col</span> في نفس الورقة. استخدمنا مجموعة تدريب بحجم <span class="nodecor">140,000</span> ومجموعة تحقق بحجم <span class="nodecor">10,000</span>.</p>
</dd>
<dt>مشكلة الحقيبة.</dt>
<dd><p>قمنا ببناء نماذج تحتوي على <span class="nodecor">20</span> إلى <span class="nodecor">40</span> عنصرًا وحللناها للوصول إلى القيمة المثلى <span class="math inline">\(V^*\)</span>. ثم، أنشأنا نموذجين، واحد قابل للتحقيق وآخر غير قابل للتحقيق بتكلفة هدف <span class="nodecor">1.02</span> <span class="math inline">\(V^*\)</span> و<span class="nodecor">0.98</span> <span class="math inline">\(V^*\)</span>، على التوالي. يستفيد ترميزنا من نموذج الحقيبة القياسي الذي يتميز بقيد <span style="font-variant: small-caps;">sum</span>. تم أيضًا تقديم النموذج المحدد للحقيبة بناءً على نموذج ليو وآخرين. (<span class="nodecor">2020</span>) (<span class="nodecor">Liu_Zhang_Huang_Niu_Ma_Zhang_2020</span>). استخدمنا مجموعة تدريب بحجم <span class="nodecor">950,000</span> ومجموعة تحقق بحجم <span class="nodecor">50,000</span>.</p>
</dd>
<dt>تفاصيل التنفيذ.</dt>
<dd><p>تم تدريب جميع النماذج باستخدام PyTorch (<span class="nodecor">paszke2019pytorch</span>) وPyTorch-Geometric (<span class="nodecor">fey2019fast</span>) على وحدة معالجة الرسومات Nvidia V100 بسعة <span class="nodecor">32</span> GB لمدة تصل إلى <span class="nodecor">4</span> أيام أو حتى التقارب. تم اختيار النموذج الذي يتمتع بأفضل أداء على مجموعة التحقق. لجعل المقارنات بين الرسومات البيانية المحددة والعامة عادلة، قمنا بتدريب جميع نماذجنا باستخدام وحدة معالجة رسومات واحدة، وقمنا بضبط كل نموذج من خلال تغيير عدد الوحدات الخفية في طبقات MLP وLSTM. بالنسبة للهياكل المعمارية المحددة بالمشكلة، أعدنا استخدام نفس المعلمات الفائقة كما هو موضح في منشوراتها الأصلية. تم تدريب جميع النماذج باستخدام محسن Adam (<span class="nodecor">KingmaB14</span>) مع جدول معدل التعلم وتحليل الوزن <span class="nodecor"><span class="math inline">\(10^{-8}\)</span></span>. تم تفصيل المعلمات الفائقة الرئيسية المستخدمة لنماذجنا المختلفة في الكود المصاحب. جميع نماذجنا معبر عنها باستخدام صيغة <span style="font-variant: small-caps;">XCSP3</span>.</p>
</dd>
</dl>
<p>قمنا بتنفيذ محلل لبناء الرسم البياني من هذا التمثيل. شيفرتنا ونماذجنا المدربة متاحة للجميع.</p>
<h2 id="النتائج-دقة-المناهج">النتائج: دقة المناهج</h2>
<p>تلخص الجدول [table:main-results] الدقة في التنبؤ بالإجابة الصحيحة على مجموعة التحقق لكل مشكلة وخط أساس. من المثير للاهتمام، نلاحظ أن منهجنا يحقق أداءً مماثلًا أو قريبًا للهياكل المعمارية المحددة للمشكلة لجميع المشكلات. نرى ذلك كنتيجة واعدة، حيث يمكن استخدام منهجنا مباشرة لجميع المشكلات دون الحاجة إلى تصميم هيكل معماري جديد مخصص. من ناحية أخرى، يفشل منهج (<span class="nodecor">Marty_François_Tessier_Gauthier_Rousseau_Cappart_2023</span>) في تحقيق نتائج مماثلة باستثناء تلوين الرسم البياني. وذلك لأن هذا التمثيل لا يحافظ على البنية التركيبية للقيود المعقدة (<span style="font-variant: small-caps;">Col</span> لديه فقط قيود مثل <span class="math inline">\(x_1 \neq x_2\)</span>).</p>
<p>بينما يحقق <span style="font-variant: small-caps;">TSP-Elem</span> نتائج قريبة من المنهج المحدد لـTSP، يقصر <span style="font-variant: small-caps;">TSP-Ext</span> بشكل كبير. هذا يبرز أهمية استخدام نموذج تركيبي مناسب للترميز. على وجه التحديد، يحتوي الترميز <span style="font-variant: small-caps;">TSP-Elem</span> على حجم يبلغ <span class="math inline">\(1841\)</span> رأسًا و<span class="math inline">\(13042\)</span> حافة، بينما ينتج <span style="font-variant: small-caps;">TSP-Ext</span> رسمًا بيانيًا يحتوي على <span class="math inline">\(5661\)</span> رأسًا و<span class="math inline">\(28322\)</span> حافة، لنفس مثيل المدينة البالغ عددها 40 مدينة. وهذا يعتبر ترميزًا أكبر، وهو غير مرغوب فيه لأنه يجعل النموذج أصعب في التدريب.</p>
<h2 id="تحليل-التعميم-على-نماذج-أكبر">تحليل: التعميم على نماذج أكبر</h2>
<p>يظهر الشكل المرجعي <span class="nodecor">fig:generalization</span> قدرة التعميم للنموذج السابق، دون إعادة تدريب، على نماذج جديدة بـ<span class="nodecor">60</span>، <span class="nodecor">80</span> و<span class="nodecor">100</span> متغير (<span class="nodecor">5000</span> نموذج لكل حجم). نلاحظ أن تمثيلنا العام يوفر تعميمًا أفضل من البنية المحددة للمشكلة لـ<span class="nodecor">SAT</span> و<span class="nodecor">TSP</span>. بشكل لافت، <span class="nodecor">TSP-Elem</span> يقدم تعميمًا أفضل بكثير من <span class="nodecor">TSP-Ext</span>، مما يؤكد تأثير نموذج الإدخال وحجم الرسم البياني. من المثير للاهتمام، نلاحظ قدرة تعميم قوية للبنية المحددة لمشكلة الحقيبة. تشير تحليلاتنا الأولية إلى أن هذا يتحقق بفضل دالة تجميع GNN تعتمد على مجموع موزون. فهم الأسباب الجذرية لهذا التعميم بالتفصيل هو جزء من عملنا المستقبلي.</p>
<h2 id="المناقشة-القيود-والتحديات">المناقشة: القيود والتحديات</h2>
<p>على الرغم من أن النتائج التجريبية تظهر وعد هذه البنية العامة، يجب معالجة بعض القيود. أولاً، الوقت المطلوب للتدريب للحصول على مثل هذه النتائج كبير، على الرغم من أننا اعتبرنا حتى الآن حالات صغيرة نسبيًا. هذا بشكل رئيسي لأن ترميزنا يولد رسومات كبيرة. هذا يفتح الباب لدمج طرق الضغط، المخصصة لتقليص حجم الترميز دون فقدان المعلومات. يمكن العمل بالتوازي مع قيود (<span class="nodecor">smartTable</span>) (<span class="nodecor">mairy2015smart</span>)، والتي ترمز الجداول بشكل أكثر اختصارًا. كما يسلط الضوء على أهمية وجود نموذج إدخال جيد، ينتج تضمينًا صغيرًا (على سبيل المثال، <span class="nodecor">TSP-Elem</span> مقابل <span class="nodecor">TSP-Ext</span>). بالإضافة إلى ذلك، المهمة الحالية مقصورة على حل النسخة القرارية من المشكلات بنهج من البداية إلى النهاية. الخطوة التالية ستكون دمج هذه البنية في حل كامل، كما تم اقتراحه من قبل جاس وآخرين (<span class="nodecor">Gasse_Chetelat_Ferroni_Charlin_Lodi_2019</span>) للبرامج الصحيحة المختلطة الثنائية، ومن قبل كابارت وآخرين (<span class="nodecor">cappart2021combining</span>) للبرمجة بالقيود. أخيرًا، قدرة التعميم لنموذج تم تدريبه لمشكلة محددة (على سبيل المثال، على <span class="nodecor">TSP</span>) لمشكلة مماثلة (على سبيل المثال، <span class="nodecor">TSP</span> مع نوافذ زمنية) هي جانب مثير للاهتمام للتحقيق.</p>
<h1 id="الخلاصة-والآفاق">الخلاصة والآفاق</h1>
<p>قدم هذا البحث نسخة أولية من إجراء عام لترميز حالات المشكلات التركيبية المختلفة إلى رسم بياني للتعلم بناءً على النهج المستخدم. الرمز المقترح هو حقني، مما يعني أن كل ترميز يمكن الحصول عليه من خلال حالة واحدة فقط. بالإضافة إلى ذلك، تم اقتراح شبكة عصبية مخصصة للرسم البياني للتعلم من هذا الترميز. أظهرت النتائج التجريبية أن نهجنا يمكن أن يحقق نتائج مماثلة للهياكل المعمارية المحددة للمشكلة، دون الحاجة إلى تصميم تمثيل مخصص يدويًا. جميع القيود المشاركة في مسابقة المسار المصغر لعام <span class="nodecor">2023</span> مدعومة حاليًا. إضافة قيود جديدة تتطلب فقط تنفيذ محلل. خطواتنا التالية هي تحدي النهج على مشكلات أكبر وأكثر تعقيدًا، وعلى مهام تركيبية أخرى (مثل تعلم الاستدلالات الفرعية).</p>
<h1 id="الشكر-والتقدير" class="unnumbered">الشكر والتقدير</h1>
<p>تم تمويل هذا البحث بشكل رئيسي بفضل منحة اكتشاف <span class="nodecor">NSERC</span> (كندا) التي يحملها كوينتن كابارت. تلقى هذا البحث تمويلاً من برنامج الاتحاد الأوروبي للبحث والابتكار <span class="nodecor">Horizon 2020</span> بموجب اتفاقية منحة رقم <span class="nodecor">101070149</span>، مشروع <span class="nodecor">Tuples</span>.</p>
</body>
</html>
