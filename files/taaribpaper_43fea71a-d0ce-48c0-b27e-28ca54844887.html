<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Léo Boisvert">
  <meta name="author" content="Hélène Verhaeghe">
  <meta name="author" content="Quentin Cappart">
  <title>نحو تمثيل عام لمشكلات توافقيّة للمقاربات القائمة على التعلُّم</title>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap');
    html, body {
      font-family: 'Cairo', 'Segoe UI', Tahoma, Geneva, Verdana, Arial, sans-serif;
      background: #f8f9fa;
      color: #222;
      font-size: 22px;
      line-height: 1.7;
      margin: 0;
      padding: 0;
      direction: rtl;
    }
    body {
      max-width: 900px;
      margin: 40px auto 40px auto;
      padding: 32px 24px 32px 24px;
      background: #fff;
      border-radius: 18px;
      box-shadow: 0 4px 32px 0 rgba(0,0,0,0.08);
    }
    header {
      text-align: center;
      margin-bottom: 40px;
    }
    h1.title {
      font-size: 2.3em;
      font-weight: 700;
      color: #1a237e;
      margin-bottom: 0.2em;
      margin-top: 0;
      letter-spacing: 0.01em;
    }
    .author {
      font-size: 1.1em;
      color: #374151;
      margin: 0.1em 0;
      font-weight: 500;
    }
    h1, h2 {
      color: #283593;
      font-weight: 700;
      margin-top: 2.2em;
      margin-bottom: 0.7em;
      border-bottom: 2px solid #e3e6f0;
      padding-bottom: 0.2em;
      letter-spacing: 0.01em;
    }
    h2 {
      font-size: 1.3em;
      margin-top: 1.7em;
    }
    h1.unnumbered {
      border-bottom: none;
      margin-top: 2.5em;
    }
    p {
      margin: 1.1em 0;
      text-align: justify;
    }
    em {
      color: #1565c0;
      font-style: normal;
      font-weight: 600;
    }
    strong {
      color: #b71c1c;
      font-weight: 700;
    }
    a, a:visited {
      color: #1976d2;
      text-decoration: underline;
      word-break: break-all;
    }
    a:hover {
      color: #0d47a1;
      text-decoration: underline;
    }
    code, .math.inline {
      background: #f1f3f4;
      color: #c62828;
      font-family: 'Cairo', 'Consolas', 'monospace';
      font-size: 0.98em;
      border-radius: 4px;
      padding: 0.1em 0.3em;
      margin: 0 0.1em;
    }
    pre {
      background: #f1f3f4;
      color: #263238;
      border-radius: 6px;
      padding: 1em;
      overflow-x: auto;
      font-size: 0.95em;
      margin: 1.2em 0;
      direction: ltr;
      text-align: left;
    }
    dl {
      background: #f5f7fa;
      border-radius: 10px;
      padding: 1.2em 1.5em;
      margin: 2em 0;
      border-right: 4px solid #1976d2;
    }
    dt {
      font-weight: 700;
      color: #283593;
      margin-top: 1.1em;
      margin-bottom: 0.2em;
      font-size: 1.08em;
    }
    dd {
      margin: 0 0 1.1em 0;
      padding: 0 0 0 1.5em;
    }
    ul, ol {
      margin: 1.2em 2.5em 1.2em 0;
      padding: 0 1.5em 0 0;
    }
    li {
      margin-bottom: 0.5em;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      margin: 2em 0;
      background: #fafbfc;
      border-radius: 8px;
      overflow: hidden;
      font-size: 0.98em;
    }
    th, td {
      border: 1px solid #e3e6f0;
      padding: 0.7em 1em;
      text-align: center;
    }
    th {
      background: #e3e6f0;
      color: #283593;
      font-weight: 700;
    }
    tr:nth-child(even) {
      background: #f5f7fa;
    }
    .nodecor {
      text-decoration: none !important;
      color: inherit !important;
      font-weight: inherit !important;
    }
    .highlight-box {
      background: #e3f2fd;
      border-right: 5px solid #1976d2;
      border-radius: 8px;
      padding: 1em 1.5em;
      margin: 1.5em 0;
      font-size: 1.02em;
    }
    .math.inline {
      font-family: 'Cairo', 'Consolas', 'monospace';
      font-size: 1em;
      color: #1565c0;
      background: none;
      padding: 0;
      border-radius: 0;
    }
    @media (max-width: 600px) {
      body {
        padding: 10px 2vw 10px 2vw;
        font-size: 18px;
      }
      header {
        margin-bottom: 20px;
      }
      h1.title {
        font-size: 1.3em;
      }
    }
  </style>
</head>
<body>
<header>
  <h1 class="title">نحو تمثيل عام لمشكلات توافقيّة للمقاربات القائمة على التعلُّم</h1>
  <p class="author"><span class="nodecor">Léo Boisvert</span></p>
  <p class="author"><span class="nodecor">Hélène Verhaeghe</span></p>
  <p class="author"><span class="nodecor">Quentin Cappart</span></p>
</header>

<h1 id="ملخص">مُلَخَّص</h1>
<p>في السنوات الأخيرة، ازداد الاهتمام باستخدام المقاربات القائمة على التعلُّم لحلّ المشكلات التوافقيّة، سواء من البداية إلى النهاية أو بالتعاون مع خوارزميّات التحسين التقليدية. في كلا السيناريوهين، يكمن التحدّي في ترميز مثيلات المشكلات المستهدفة في صيغة ملائمة لخوارزميّات التعلُّم. لقد اقترحت أعمالٌ عديدة تمثيلاتٍ مخصّصة للمشكلة، غالبًا على شكل رسمٍ بياني، للاستفادة من مزايا <em>الشبكات العصبية البيانيّة</em>. ومع ذلك، تفتقر هذه المقاربات إلى العموميّة، إذ لا يمكن نقل التمثيل بسهولة من مشكلة توافقيّة إلى أخرى. وعلى الرغم من بعض المحاولات لسدّ هذه الفجوة، فإنها ما زالت تقدّم عموميّة جزئية فقط. استجابةً لهذا التحدّي، يدعو هذا البحث إلى التقدّم نحو تمثيلٍ عامٍّ كاملٍ لمشكلاتٍ توافقيّة في سياق المقاربات القائمة على التعلُّم. يتضمن النهج المقترح بناءَ رسمٍ بياني عبر تحليل أيّ قيد في مثيل المشكلة إلى شجرة بنيةٍ نحويّة مُجرَّدة والتعبير عن العلاقات (مثل مشاركة متغيّر في قيد) بواسطة الحواف. علاوةً على ذلك، نقدّم بنية شبكةٍ عصبيةٍ بيانيّة قادرة على التعلُّم بكفاءة من هذا التمثيل. تعمل أداتُنا مباشرةً على مثيلاتٍ مُعبَّر عنها بتنسيق <span class="nodecor">XCSP3</span>، مُعالجةً جميع القيود المتاحة في <span class="nodecor">المسار المُصغَّر</span> لعام <span class="nodecor">2023</span>. تُظهر النتائج التجريبية على أربع مسائل توافقيّة أن بنيتنا تُحقّق أداءً مماثلًا للبُنى المخصّصة مع الحفاظ على العموميّة. تتوفر شِفرتُنا ونماذجُنا المُدرَّبة على <a href="https://github.com/corail-research/learning-generic-csp" class="uri">https://github.com/corail-research/learning-generic-csp</a>.</p>

<h1 id="مقدمة">مُقَدِّمَة</h1>
<p>لقد جذبت مسائلُ التحسين التوافقي اهتمامَ باحثي علوم الحاسوب منذ نشأة هذا المجال. وكانت مشكلاتٌ مثل <span class="nodecor">مشكلة البائع المتجوّل</span> و<span class="nodecor">الإشباع البولياني</span> محورَ بحثٍ مستمرّ لعقود. ويمكننا الآن حلّ نماذج كبيرةٍ من هذه الأنواع بكفاءةٍ باستخدام الأساليب الدقيقة (<span class="nodecor">Applegate2009</span>) والإجراءات التقريبيّة (<span class="nodecor">36b9628e7a874d208624584d8a470985</span>). هذه الاستراتيجيات تُجسِّد خبرةَ الخبراء في بنية المشكلات المُستهدفة. وعلى الرغم من نجاحها الواسع في المشكلات التوافقيّة سواء كحلّ مباشر أو داخل إجراءات البحث، فقد جذب ظهورُ <span class="nodecor">التعلُّم العميق</span> في مجالات عديدة (<span class="nodecor">Bahdanau_Cho_Bengio_2016</span>, <span class="nodecor">brown2020language</span>, <span class="nodecor">Krizhevsky_Sutskever_Hinton_2012</span>, <span class="nodecor">mnih2015human</span>) اهتمامَ الباحثين (<span class="nodecor">Prouvost_2020</span>). ومن بين هياكل <span class="nodecor">التعلُّم العميق</span>، أثبتت <em>الشبكات العصبية البيانيّة</em> (<span class="nodecor">GNNs</span>) (<span class="nodecor">Scarselli_Gori_Tsoi_Hagenbuchner_Monfardini_2009</span>) أنها أداةٌ قوية ومرنة لحل هذه المشكلات. ومع ذلك، كما أشار <span class="nodecor">Cappart et al.</span> (2023) (<span class="nodecor">cappart2021combinatorial</span>)، لا يزال من الصعب إدماج <span class="nodecor">GNN</span> و<span class="nodecor">التعلُّم الآلي</span> ضمن إجراءات الحلّ المستخدمة عمليًا. ومن الأسبابِ الرئيسة لذلك أنّه يجب تصميمُ وتدريبُ بنيةٍ مخصّصة لكلّ مشكلةٍ توافقيّة. وإضافةً إلى الموارد الحاسوبيّة المُكلفة المحتملة للتدريب، يتطلّب ذلك أيضًا وجودَ مجموعةِ تدريبٍ كبيرةٍ وموسومة.</p>
<p>اعتمدت معظمُ المقاربات ذات الصلة على إنشاء تمثيلٍ بيانيٍّ مخصّص للمشكلة، مثل <span class="nodecor">NeuroSAT</span> (<span class="nodecor">Selsam2018</span>) الذي يستفيد من ترميز صيغ <span class="nodecor">SAT</span>، أو الأساليب المُرتبطة وثيقًا بـ<span class="nodecor">مشكلة البائع المتجوّل</span> (<span class="nodecor">Prates_Avelar_Lemos_Lamb_Vardi_2018</span>, <span class="nodecor">joshi2022learning</span>). وتعاني هذه الأساليب من محدوديّة العموميّة، إذ لا يمكن نقل بنية التمثيل ببساطة من مشكلةٍ توافقيّة إلى أخرى. وعلى الرغم من بعض المحاولات لسدّ هذه الفجوة، فإنها لا تزال تُوفِّر عموميّةً جزئيّة فقط. على سبيل المثال، اقترح <span class="nodecor">Gasse et al.</span> (2019) (<span class="nodecor">Gasse_Chetelat_Ferroni_Charlin_Lodi_2019</span>) رسمًا ثنائيَّ الطبقات يربط بين المتغيّرات والقيود عندما يشارك المتغيّر في قيدٍ معين. غير أنّ هذا النهج يشفّر فقط <em>البرمجة الخطّية الصحيحة المُختلطة</em> (MILP). ولاحقًا، قدّم <span class="nodecor">Chalumeau et al.</span> (2021) (<span class="nodecor">chalumeau2021seapearl</span>) رسمًا ثلاثيَّ الطبقات حيث المتغيّرات والقيم والقيود هي أنواعٌ مميّزة من الرؤوس. ويُعاني هذا الإطار من قصورٍ مماثل في العموميّة، إذ قد يتطلّب إعادةَ تدريب النموذج عند تغيير عدد المتغيّرات. وحتى الآن، كان آخر المقترحات عملَ <span class="nodecor">Marty et al.</span> (2023) (<span class="nodecor">Marty_François_Tessier_Gauthier_Rousseau_Cappart_2023</span>) الذي استخدم رسمًا ثلاثيَّ الطبقات يسمح بإضافة ميزاتٍ مخصّصة لكل نوع رأس. وعلى الرغم من أنّ أيّ مشكلة توافقيّة يمكن نظريًا ترميزُها بهذا الإطار، فإن بعضَ المعلومات يضيع في العملية. فعلى سبيل المثال، يصعب التمييز بين القيد <span class="math inline">\(3x_1 \leq 4x_2\)</span> والقيد <span class="math inline">\(2x_1 \leq 5x_2\)</span>. فمن جهة، قد نُصنِّفهما على أنهما <em>عدم مساواة</em> فحسب، لكنّنا نفقد تفاصيل المعاملات. ومن جهةٍ أخرى، قد نُعاملهما بوصفهما علاقتين مختلفتين، لكنّنا نفقد الصفةَ الأساسية المشتركة. بعبارةٍ أخرى، لم تكن دالّة التشفير لديهم <em>حَقنيّة</em>؛ إذ قد تتشارك حالاتٌ مختلفةٌ التمثيلَ نفسه من دون إمكانية التمييز بينها. علاوةً على ذلك، استهدفت تلك التجارب مشكلاتٍ علائقيّة بحتة (<em>المجموعة المستقلة القصوى</em>، <em>القطع الأقصى</em>، <em>تلوين الرسم</em>) فقط. وتواجه قيودٌ مماثلةٌ نهجَ <span class="nodecor">Tönshoff et al.</span> (2022) (<span class="nodecor">Tönshoff_Kisin_Lindner_Grohe_2022</span>).</p>
<p>استنادًا إلى هذا السياق، نتقدّم في هذا البحث نحو تمثيلٍ عامّ تمامًا للمشكلات التوافقيّة المعتمدة على التعلُّم. فكرتُنا الأساسية هي تفكيكُ أيّ قيد في مثيل المشكلة إلى <em>شجرة بنيةٍ نحويّة مُجرَّدة</em>، ثم ربط العناصر المُتماثلة (مثل المتغيّر أو القيمة نفسها) بواسطة حواف. بعد ذلك، نقدّم بنية <span class="nodecor">GNN</span> قادرةً على استغلال هذا الرسم. ولإظهار عموميّة هذا النهج، يعمل نموذجُنا مباشرةً على مثيلاتٍ مُعبَّر عنها بتنسيق <span class="nodecor"><span style="font-variant: small-caps;">XCSP3</span></span> (<span class="nodecor">Boussemart_Lecoutre_Audemard_Piette_2022</span>)، ويُعالج جميع القيود المتاحة في <span class="nodecor">المسار المُصغَّر</span> لعام <span class="nodecor">2023</span>. أجرينا التجارب على أربع مسائل تتضمّن قيودًا قياسية وعالميّة مثل <span class="nodecor"><span style="font-variant: small-caps;">allDifferent</span></span> (<span class="nodecor">regin1994filtering</span>)، <span class="nodecor"><span style="font-variant: small-caps;">table</span></span> (<span class="nodecor">demeulenaere2016compact</span>)، <span class="nodecor"><span style="font-variant: small-caps;">negativeTable</span></span> (<span class="nodecor">verhaeghe2017extending</span>)، <span class="nodecor"><span style="font-variant: small-caps;">element</span></span> و<span class="nodecor"><span style="font-variant: small-caps;">sum</span></span>، وهدفُها التنبؤ بقابليّة الإشباع للإصدارات القرارِيّة من المشكلات التوافقيّة. وتُظهر النتائج أن بنيتَنا العامة تُقدِّم أداءً قريبًا من البُنى المخصّصة وتتفوّق على الرسم الثلاثيّ الطبقات لمارتي وآخرين (2023) (<span class="nodecor">Marty_François_Tessier_Gauthier_Rousseau_Cappart_2023</span>).</p>

<h1 id="ترميز-مثيلـات-المشكلات-التوافقيه-كرسم-بياني">ترميز مثيلات المشكلات التوافقيّة كرسمٍ بياني</h1>
<p>رسمياً، يُعرَّف مثيلُ المشكلة التوافقيّة <span class="math inline">\(\mathcal{P}\)</span> على أنه رباعي <span class="math inline">\(\langle X, D(X), C, O \rangle\)</span>، حيث <span class="math inline">\(X\)</span> هي مجموعة المتغيّرات، و<span class="math inline">\(D(X)\)</span> مجموعة النطاقات، و<span class="math inline">\(C\)</span> مجموعة القيود، و<span class="math inline">\(O\)</span> (<span class="math inline">\(X \to \mathbb{R}\)</span>) دالّة الهدف. الحلّ الصالح هو تعيينُ كل متغيّر إلى قيمةٍ من نطاقه بحيث تتحقّق جميع القيود، أمّا الحلّ الأمثل فهو الذي لا يمكن تحسين هدفه عبر حلٍّ آخر. هدفُنا هو بناءُ دالّة <span class="math inline">\(\Phi: \langle X, D(X), C, O \rangle \mapsto \mathcal{G}(V,f,E)\)</span>، حيث <span class="math inline">\(\mathcal{G}\)</span> رسمٌ بياني و<span class="math inline">\(V\)</span> و<span class="math inline">\(f\)</span> و<span class="math inline">\(E\)</span> هي مجموعاتُ الرؤوس وميزاتُها والحوافّ على التوالي. نريد لهذه الدالّة أن تكون <em>حَقنيّة</em>، أي أن يُمثِّل كلُّ ترميزٍ مثيلًا واحدًا فقط من المشكلة. نقترح تحقيق ذلك عبر رسمٍ بيانيٍّ <em>غير مُتجانس</em> وغير مُوجَّه مُكوَّنٍ من خمسة أنواع من الرؤوس: <em>المتغيّرات</em> (<span class="math inline">\(\textsc{var}\)</span>)، و<em>القيود</em> (<span class="math inline">\(\textsc{cst}\)</span>)، و<em>القِيَم</em> (<span class="math inline">\(\textsc{val}\)</span>)، و<em>العوامل/المُشغِّلات</em> (<span class="math inline">\(\textsc{ope}\)</span>)، و<em>النموذج</em> (<span class="math inline">\(\textsc{mod}\)</span>). الفكرة هي تفكيك كلّ قيدٍ إلى سلسلةٍ من العمليات الأوليّة، وجمع الرؤوس المُمثِّلة لنفس المتغيّر أو القيمة وربطها معًا. تُشبه هذه العمليةَ بناءَ <em>شجرة بنيةٍ نحويّة مُجرَّدة</em> لبرنامج. رسميًا، ينتج عنها رسمٌ بياني <span class="math inline">\(\mathcal{G}(V, f, E)\)</span> حيث <span class="math inline">\(V = V_\textsc{var} \cup V_\textsc{cst} \cup V_\textsc{val} \cup V_\textsc{ope} \cup V_\textsc{mod}\)</span>، و<span class="math inline">\(f = f_\textsc{var} \cup f_\textsc{cst} \cup f_\textsc{val} \cup f_\textsc{ope} \cup f_\textsc{mod}\)</span>، و<span class="math inline">\(E\)</span> هي الحوافّ التي تربط الرؤوس وتعكسُ العلاقات داخل القيود.</p>

<h1 id="ترميز-المشكلة">ترميز المشكلة</h1>
<p>نُوضِّح الترميز على مثيلٍ تشغيلي. لدينا <span class="nodecor">3</span> رؤوس للقِيَم (باللون الأخضر) و<span class="nodecor">2</span> من رؤوس المتغيّرات (باللون الأحمر). بما أن <span class="nodecor"><span class="math inline">\(x_1\)</span></span> يمكنه أخذُ القيم <span class="nodecor">1</span> و<span class="nodecor">2</span> في نطاقه، فهو متصلٌ بحافتين، وكذلك <span class="nodecor"><span class="math inline">\(x_2\)</span></span>. هناك <span class="nodecor">2</span> من رؤوس القيود (باللون الأزرق): أحدُهما لعدم المساواة (<span class="nodecor"><span class="math inline">\(\leq\)</span></span>) والآخر لقيد الامتداد (<span class="nodecor"><span class="math inline">\(\textsf{ext}\)</span></span>) الخاص بجدول القيم. توضّح المنطقة الرماديّة القيد <span class="nodecor"><span class="math inline">\(3x_1 \leq 4x_2\)</span></span>، مع العوامل/المُشغِّلات (باللون البرتقالي) وعمليّتَي الضرب: (<span class="nodecor"><span class="math inline">\(\times\)</span></span> بميزة <span class="nodecor">3</span>) مع <span class="nodecor"><span class="math inline">\(x_1\)</span></span> على الجانب الأيمن (<span class="nodecor"><span class="math inline">\(\textsf{rhs}\)</span></span>) و(<span class="nodecor"><span class="math inline">\(\times\)</span></span> بميزة <span class="nodecor">4</span>) مع <span class="nodecor"><span class="math inline">\(x_2\)</span></span> على الجانب الأيسر (<span class="nodecor"><span class="math inline">\(\textsf{lhs}\)</span></span>). يوضّح المُشغِّلان <span class="nodecor"><span class="math inline">\(\textsf{rhs}\)</span></span> و<span class="nodecor"><span class="math inline">\(\textsf{lhs}\)</span></span> جانبي المتباينة، وهو أمرٌ ضروري للتمييز بين <span class="nodecor"><span class="math inline">\(3x_1 \leq 4x_2\)</span></span> و<span class="nodecor"><span class="math inline">\(3x_1 \geq 4x_2\)</span></span>، ويتّصلان بالقيد المناسب. ويُعبَّر عن قيد الجدول <span class="nodecor"><span class="math inline">\(\textsc{table}([x_1,x_2],[(1,2),(2,3)])\)</span></span> بطريقةٍ مماثلة عبر زوجين <span class="nodecor"><span class="math inline">\(t_1\)</span></span> و<span class="nodecor"><span class="math inline">\(t_2\)</span></span>. أخيرًا، يتصل رأسُ النموذج (باللون الأصفر) بالقيدين وبالمتغيّر <span class="nodecor"><span class="math inline">\(x_1\)</span></span> بوصفه جزءًا من دالّة الهدف.</p>
<p>كملاحظةٍ ختامية، يمكن استخدام هذا الترميز لتمثيل أيّ مثيلٍ لمشكلةٍ توافقيّة بطريقةٍ فريدة. ويتطلّب ذلك تطويرَ محلِّلٍ لكل قيد يحدّد كيفية تفكيكه إلى مُشغِّلات ومتغيّرات. نحن ندعم حاليًا جميع القيود المُدرجة في نص <span class="nodecor">XCSP3-core</span> (<span class="nodecor">Boussemart_Lecoutre_Audemard_Piette_2022</span>) والمستخدمة في مسارات <span class="nodecor">المسار المُصغَّر</span> لمسابقات <span class="nodecor">XCSP-2023</span>: المساواة الثنائية، جدول القيم، الجدول السلبي، الجدول القصير، <span class="nodecor"><span style="font-variant: small-caps;">element</span></span>، و<span class="nodecor"><span style="font-variant: small-caps;">sum</span></span>. يحتوي مستودعُنا على الوثائق اللازمة لبناء الرسم البياني لأيّ مثيلٍ بصيغة XCSP3-core ووصفِ جميع الميزات المدعومة.</p>

<h1 id="sec:gnn">التعلُّم من الترميز باستخدام شبكة عصبية بيانيّة</h1>
<p>لتحقيق الخطوة التالية و<em>التعلُّم</em> من هذا التمثيل، صمّمنا بنيةَ <em>شبكةٍ عصبيةٍ بيانيّة</em> مخصّصة للاستفادة من هذا الترميز. شبكةٌ عصبيةٌ بيانيّة هي بنيةٌ متخصّصة مصمّمة لحساب التمثيل الكامن (التضمين) لكلّ رأسٍ في الرسم البياني المعطى (<span class="nodecor">Scarselli_Gori_Tsoi_Hagenbuchner_Monfardini_2009</span>) عبر تجميع المعلومات من الرؤوس المجاورة بشكلٍ تكراري. تُشار إلى كل خطوة تجميع بـ<em>طبقة</em> وتتضمن أوزانًا قابلةً للتعلّم. وتوجد عدةُ طرائق للتجميع معروفة في الأدبيات (<span class="nodecor">li2016gated</span>, <span class="nodecor">monti2017geometric</span>, <span class="nodecor">velivckovicgraph</span>). النموذج قابلٌ للاشتقاق ويمكن تدريبه باستخدام الانحدار التدريجي.</p>
<p>لنفترض أنّ <span class="math inline">\(\mathcal{G}(V, f, E)\)</span> هو الترميز البياني المُحتسب مسبقًا، ولْيكن <span class="math inline">\(h^{[i]}_{t,v} \in \mathbb{R}^{p}\)</span> التمثيلَ المتّجه ذا البُعد <span class="math inline">\(p\)</span> للرأس <span class="math inline">\(v \in V_t\)</span> في التكرار <span class="math inline">\(i \in \{0, \ldots, I\}\)</span>. تُعرَف عمليةُ الاستدلال في الشبكات العصبية البيانيّة بـ<em>تمرير الرسائل</em>، حيث نحسب التمثيلات الجديدة <span class="math inline">\(h^{[i+1]}_{t,v}\)</span> انطلاقًا من السابقة. أولًا، نُعيّن <span class="math inline">\(h^{[0]}_{t,v} = f_{t,v}\)</span> لكل رأس، حيث <span class="math inline">\(f_{t,v}\)</span> هو متّجه ميزاته. ثم نجري <span class="math inline">\(I\)</span> خطواتٍ من تمرير الرسائل، يشمل كلٌّ منها تجميع الرسائل من الجيران، وتحويلَها عبر <span class="math inline">\(\mathsf{MLP}^{\mathsf{in}}_{t_1,t_2}\)</span> مخصّصةٍ لكل نوع حافة ودمجَها (<span class="math inline">\(\bigoplus\)</span>)، ثم تحديثَ التمثيل بواسطة خلية LSTM (<span class="math inline">خليّة لكلّ نوعٍ \(t\)</span>). وأخيرًا، نمرّر <span class="math inline">\(h^{[I]}_{t,v}\)</span> عبر <span class="math inline">\(\mathsf{MLP}^{\mathsf{out}}_{t}\)</span> للحصول على المخرجات <span class="math inline">\( \nu_{t,v}\)</span>، ثم نوسِّطها ونطبّق دالّة سيغمويد لإنتاج التنبؤ <span class="math inline">\(\hat{y}\)</span>.</p>
<div class="highlight-box">
  <p><span class="math inline">\(\triangleright\)</span> <strong>المعطيات:</strong> <span class="math inline">\(\mathcal{G}(V_{\textsc{var},\textsc{cst},\textsc{val},\textsc{ope},\textsc{mod}}, f_{\textsc{var},\textsc{cst},\textsc{val},\textsc{ope},\textsc{mod}}, E)\)</span> هو الترميز البياني.</p>
  <p><span class="math inline">\(\triangleright\)</span> <strong>المعطيات:</strong> <span class="math inline">\( \mathcal{T} = \{\textsc{var},\textsc{val},\textsc{cst},\textsc{ope},\textsc{mod}\}\)</span> هي مجموعة <em>أنواع الرؤوس</em>.</p>
  <p><span class="math inline">\(\triangleright\)</span> <strong>المعطيات:</strong> <span class="math inline">\(I\)</span> هو عددُ تكرارات الشبكة العصبية البيانيّة.</p>
  <p><span class="math inline">\(h^{[0]}_{t,v} := f_{t,v} \quad \forall v \in V_t, \forall t \in \mathcal{T}\)</span> <!-- [eql:1] --></p>
  <p><span class="math inline">\(\gamma^{[0]}_{t,v} := 0 \quad \forall v \in V_t, \forall t \in \mathcal{T}\)</span> <!-- [eql:2] --></p>
  <!-- تمرير الرسائل (غير مفصَّل هنا) -->
  <p><span class="math inline">\( \nu_{t,v} := \mathsf{MLP}^{\mathsf{out}}_{t}\bigl(h^{[I]}_{t,v}\bigr) \quad \forall v \in V_t, \forall t \in \mathcal{T}\)</span> <!-- [eql:6] --></p>
  <p><span class="math inline">\(\hat{y} := \sigma\left(\frac{1}{|\mathcal{T}|\times |V|}\sum_{t \in \mathcal{T}}\sum_{v \in V_t}\nu_{t,v}\right)\)</span> <!-- [eql:7] --></p>
  <p><strong>المخرَج:</strong> <span class="math inline">\(\hat{y}\)</span> <!-- [eql:8] --></p>
</div>

<h1 id="sec:exp">التجارب</h1>
<p>يُقيِّم هذا القسم منهجيّتَنا على مهامّ توافقيّة، مع التركيز على أربع مسائل: الإشباعُ البولياني (<span style="font-variant: small-caps;">SAT</span>)، تلوينُ الرسم البياني (<span style="font-variant: small-caps;">COL</span>)، مشكلةُ الحقيبة (<span style="font-variant: small-caps;">Knap</span>)، ومشكلةُ البائع المتجوّل (<span style="font-variant: small-caps;">TSP</span>) مع صياغتَي <span style="font-variant: small-caps;">TSP-Ext</span> (قيد الامتداد/الجدول) و<span style="font-variant: small-caps;">TSP-Elem</span> (قيد <span style="font-variant: small-caps;">element</span>). درّبنا النماذج على الإصدارات القرارِيّة من المشكلات، مُستَعلمِين عمّا إذا كان هناك حلٌّ بتكلفةٍ أقلّ من الهدف <span class="math inline">\(k\)</span>. وفي حال عدم وجود دالّة هدف، تصبح المسألةُ مسألةَ إشباعٍ (مثل <span style="font-variant: small-caps;">SAT</span>) حيث يهدف النموذج إلى تحديد وجود حلّ. قارَنّا منهجيّتَنا مع بُنى معماريّة مُخصّصة لكلّ مشكلة، ومع الرسم الثلاثيّ الطبقات لمارتي وآخرين (2023) (<span class="nodecor">Marty_François_Tessier_Gauthier_Rousseau_Cappart_2023</span>). استخرجنا تمثيلَهم البياني واستخدمناه في شبكتنا. المقياسُ التقييمي المُعتمد هو الدقّة في التنبؤ الصحيح بوجود الحلّ في النسخة القرارِيّة. وتَرِدُ سائر التفاصيل في بروتوكولنا التجريبي وفي قسم تفاصيل التنفيذ.</p>
<dl>
<dt>الإشباع البولياني.</dt>
<dd><p>أُنشِئت المثيلات باستخدام المُولِّد العشوائي لـ<span class="nodecor">Selsam et al.</span> (2018) (<span class="nodecor">Selsam2018</span>). باختصار، يُولِّد هذا المُولِّد أزواجًا من مثيلات <span style="font-variant: small-caps;">SAT</span> ذات <span class="math inline">\(n\)</span> متغيّرات عن طريق إضافة شروطٍ عشوائية حتى تُصبح المسألة غيرَ قابلةٍ للإشباع، ثم يُقلَّب إشارةُ أحد المتغيّرات لجعلها قابلةً للإشباع. في المتوسط، تضمّ الشروط نحو <span class="nodecor">8</span> حدود. ضمِمْنا كلا توزيعي القابل وغير القابل للإشباع في مجموعة البيانات. كما في العمل الأصلي، أنشأنا مجموعةَ تدريبٍ مؤلّفةً من <span class="nodecor">3,980,000</span> مثيلًا ومجموعةَ تحقُّقٍ من <span class="nodecor">20,000</span> مثيل.</p>
</dd>
<dt>مشكلة البائع المتجوّل.</dt>
<dd><p>أُنشِئت المثيلات باستخدام مُولِّد <span class="nodecor">Prates et al.</span> (2018) (<span class="nodecor">Prates_Avelar_Lemos_Lamb_Vardi_2018</span>). ويتكوّن التوليد من: (1) توزيع <span class="math inline">\(n\)</span> نقاط عشوائيًا في المربّع <span class="math inline">\([0,1]^2\)</span>، (2) حساب مصفوفة المسافات الإقليدية، و(3) حلّ المثيل بالمحلّل Concorde (<span class="nodecor">applegate2006concorde</span>) للحصول على التكلفة المثلى <span class="math inline">\(C^*\)</span>. ثم أنشأنا مثيلَين قرارِيَّين: أحدُهما قابلٌ للإشباع بهدف <span class="nodecor">1.02</span>×<span class="math inline">\(C^*\)</span> والآخر غيرُ قابلٍ للإشباع بهدف <span class="nodecor">0.98</span>×<span class="math inline">\(C^*\)</span>. بنينا صياغتَين لـ<span style="font-variant: small-caps;">TSP</span>: الأولى باستخدام قيد الامتداد (<span style="font-variant: small-caps;">TSP-Ext</span>)، والثانية باستخدام قيد <span style="font-variant: small-caps;">element</span> (<span style="font-variant: small-caps;">TSP-Elem</span>)، لدراسة أثر الصياغة على الترميز البياني والأداء. كما في السابق، بنينا مجموعةَ بياناتٍ لمدنٍ <span class="math inline">\(n\)</span> تراوحت بين <span class="nodecor">20</span> و<span class="nodecor">40</span> مدينة. استخدمنا <span class="nodecor">850,000</span> مثيلًا للتدريب و<span class="nodecor">50,000</span> للتحقُّق.</p>
</dd>
<dt>تلوين الرسم البياني.</dt>
<dd><p>اتّبعنا مُولِّد <span class="nodecor">lemos2019graph</span> لإنشاء رسومٍ ذات <span class="nodecor">40</span> إلى <span class="nodecor">60</span> رأسًا. ولكلّ رسم، نُضيف حافةً واحدةً لتغيير قابلية التلوين بـ<span class="math inline">\(k\)</span>. ونُنتج مثيلَين: قيمةٌ مثلى = <span class="math inline">\(k\)</span> وأخرى أعلى. يستفيد ترميزُنا من قيد <span class="math inline">\(\neq\)</span>. استخدمنا <span class="nodecor">140,000</span> مثيلًا للتدريب و<span class="nodecor">10,000</span> للتحقُّق.</p>
</dd>
<dt>مشكلة الحقيبة.</dt>
<dd><p>أنشأنا مثيلاتٍ من <span class="nodecor">20</span> إلى <span class="nodecor">40</span> عنصرًا وحللناها لإيجاد القيمة المثلى <span class="math inline">\(V^*\)</span>. ثم أنشأنا مثيلَين قرارِيَّين: قابلًا وغيرَ قابلٍ بالإهداف <span class="nodecor">1.02</span>×<span class="math inline">\(V^*\)</span> و<span class="nodecor">0.98</span>×<span class="math inline">\(V^*\)</span> على التوالي. يستفيد ترميزُنا من قيد <span style="font-variant: small-caps;">sum</span>. استخدمنا <span class="nodecor">950,000</span> مثيلًا للتدريب و<span class="nodecor">50,000</span> للتحقُّق.</p>
</dd>
<dt>تفاصيل التنفيذ.</dt>
<dd><p>درّبنا جميع النماذج باستخدام PyTorch (<span class="nodecor">paszke2019pytorch</span>) وPyTorch-Geometric (<span class="nodecor">fey2019fast</span>) على بطاقة Nvidia V100 بسعة <span class="nodecor">32</span> GB لمدّة تصل إلى <span class="nodecor">4</span> أيام أو حتى التقارب. اخترْنا النموذجَ الأفضل على مجموعة التحقّق. ولضمان عدالة المقارنة بين البُنى المعماريّة الخاصة والعامة، استخدمنا بطاقةً واحدةً وثبّتْنا عدد الوحدات الخفيّة في MLP وLSTM. وبالنسبة للنماذج المخصّصة، احتفظْنا بالمعلمات الفائقة نفسها المذكورة في منشوراتها الأصليّة. درّبنا كلّ النماذج بمُحسِّن Adam (<span class="nodecor">KingmaB14</span>) مع جدول لمعدّل التعلّم وتخميدِ أوزانٍ قدرُه <span class="nodecor"><span class="math inline">\(10^{-8}\)</span></span>. يمكن العثور على جميع المعلمات الفائقة في الشيفرة المرافقة. وجميع مثيلاتنا مُعبَّر عنها بصيغة <span style="font-variant: small-caps;">XCSP3</span>.</p>
</dd>
</dl>
<p>قمنا بتنفيذ مُحلِّلٍ لبناء الرسم البياني وفق هذا الترميز. شِفرتُنا ونماذجُنا المُدرَّبة متاحةٌ للجمهور.</p>

<h2 id="النتائج-دقة-المناهج">النتائج: دقّة المناهج</h2>
<p>يوضح الجدول [table:main-results] الدقّة في التنبؤ بالإجابة الصحيحة على مجموعة التحقّق لكلّ مشكلةٍ وخطّ أساس. ومن المثير للاهتمام أن منهجَنا يُحقق أداءً مماثلًا للبُنى المخصّصة لكلّ مشكلة. نرى في ذلك نتيجةً واعدة، إذ يمكن استخدام منهجنا مباشرةً دون الحاجة إلى تصميم بنيةٍ جديدةٍ مخصّصة. وعلى النقيض، تراجع منهج <span class="nodecor">Marty_François_Tessier_Gauthier_Rousseau_Cappart_2023</span> في جميع المشكلات باستثناء تلوين الرسم البياني، وذلك لأن هذا التمثيل لا يُحافظ على البنية التركيبيّة للقيود المعقّدة.</p>
<p>وبينما يُحقّق <span style="font-variant: small-caps;">TSP-Elem</span> نتائجَ قريبةً من النموذج المخصّص لـTSP، يقصر <span style="font-variant: small-caps;">TSP-Ext</span> بشكلٍ واضح. وهذا يُبيّن أهمية اختيار صياغة إدخالٍ مناسبة للترميز. فمثلًا، يُنتج <span style="font-variant: small-caps;">TSP-Elem</span> ترميزًا بحجم <span class="math inline">\(1841\)</span> رأسًا و<span class="math inline">\(13042\)</span> حافة، بينما يُولِّد <span style="font-variant: small-caps;">TSP-Ext</span> رسمًا بيانيًا مُكوَّنًا من <span class="math inline">\(5661\)</span> رأسًا و<span class="math inline">\(28322\)</span> حافة للمثيل نفسه، ما يُصعِّب التدريب بسبب الحجم الأكبر.</p>

<h2 id="تحليل-التعميم-على-نماذج-أكبر">تحليل: التعميم على مثيلاتٍ أكبر</h2>
<p>يُظهر الشكل المرجعي <span class="nodecor">fig:generalization</span> قدرةَ التعميم لنموذجنا، من دون إعادة تدريب، على مثيلاتٍ جديدة ذات <span class="nodecor">60</span> و<span class="nodecor">80</span> و<span class="nodecor">100</span> متغيّر (5000 مثيل لكلّ حجم). نُلاحظ أن تمثيلَنا العام يُوفِّر تعميمًا أفضل من البُنى المخصّصة لمشكلتَي <span class="nodecor">SAT</span> و<span class="nodecor">TSP</span>. وبشكلٍ لافت، يقدّم <span class="nodecor">TSP-Elem</span> تعميمًا أفضل بكثير من <span class="nodecor">TSP-Ext</span>، ما يؤكّد أثر صياغة الإدخال وحجم الرسم البياني. ومن المثير للاهتمام أيضًا قدرةُ التعميم القوية للنموذج المخصّص لمشكلة الحقيبة، ويُعزى ذلك مبدئيًا إلى دالّة تجميع في GNN تعتمد على مجموعٍ مُوزَّن. دراسةُ الأسباب الجذرية لهذا التعميم موضعُ بحثٍ مستقبلي.</p>

<h2 id="المناقشة-القيود-والتحديات">المناقشة: القيود والتحدّيات</h2>
<p>على الرغم من النتائج المشجّعة، هناك بعضُ التحدّيات. أوّلًا، زمنُ التدريب طويلٌ حتى على مثيلاتٍ صغيرةٍ نسبيًا، ويعود ذلك جزئيًا إلى أحجام الرسومات الناتجة. وهذا يفتح الباب لطرائق ضغطٍ خاصّة تُقلِّص حجمَ الترميز دون فقدان المعلومات، مثل قيود <span class="nodecor">smartTable</span> (<span class="nodecor">mairy2015smart</span>). كما يُبرز أهميةَ صياغة إدخالٍ تُنتج تضمينًا أصغر (مثل <span class="nodecor">TSP-Elem</span> مقارنةً بـ<span class="nodecor">TSP-Ext</span>). ثانيًا، اقتصرت المهمة الحالية على حلّ الإصدارات القرارِيّة من المشكلات من البداية إلى النهاية. وسيكون الدمجُ مع إجراءات حلٍّ كاملة، كما اقترح <span class="nodecor">Gasse_Chetelat_Ferroni_Charlin_Lodi_2019</span> للبرمجة الصحيحة المُختلطة و<span class="nodecor">cappart2021combining</span> للبرمجة بالقيود، خطوةً مهمّة. أخيرًا، يُعدّ اختبارُ تعميم النموذج المُدرَّب على مشكلةٍ معيّنة (مثل <span class="nodecor">TSP</span>) على نسخةٍ شبيهة (مثل <span class="nodecor">TSP</span> مع نوافذ زمنية) محورًا مثيرًا للاستكشاف.</p>

<h1 id="الخلاصة-والآفاق">الخلاصة والآفاق</h1>
<p>قدّم هذا البحث نُسخةً أوليّة من إجراءٍ عامّ لترميز مثيلات المشكلات التوافقيّة إلى رسمٍ بيانيٍّ مناسبٍ للتعلُّم. الترميز المقترح ذو خاصيّةِ <em>الحقن</em>، بحيث يشير كلّ تمثيلٍ إلى مثيلٍ وحيدٍ للمشكلة. وإضافةً إلى ذلك، اقترحنا بنيةَ شبكةٍ عصبيةٍ بيانيّة للتعلُّم من هذا التمثيل. وأظهرت النتائجُ التجريبيّة أنّ منهجيّتَنا تُحقّق أداءً مقاربًا للبُنى المخصّصة دون حاجةٍ إلى تصميمٍ يدويّ لمُمثِّلٍ خاص. جميع قيود <span class="nodecor">المسار المُصغَّر</span> لعام <span class="nodecor">2023</span> مدعومةٌ حاليًا؛ وإضافةُ قيودٍ جديدةٍ لا تتطلّب إلا تنفيذَ مُحلِّلٍ جديد. وتشمل خطواتُنا المقبلة تطبيقَ النهج على مشكلاتٍ أكبر وأكثر تعقيدًا وعلى مهامّ توافقيّة أخرى (مثل تعلُّم الاستدلالات الفرعيّة).</p>

<h1 id="الشكر-والتقدير" class="unnumbered">الشكر والتقدير</h1>
<p>تمّ تمويلُ هذا البحث بشكلٍ رئيسٍ بفضل منحةِ اكتشاف <span class="nodecor">NSERC</span> (كندا) التي يحملها كوينتن كابارت. كما تلقّى تمويلًا من برنامج الاتحاد الأوروبي للبحث والابتكار <span class="nodecor">Horizon 2020</span> بموجب اتفاقية منحة رقم <span class="nodecor">101070149</span>، مشروع <span class="nodecor">Tuples</span>.</p>
</body>
</html>