<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="Siyuan Li, Youshao Xiao, Fanzhuang Meng, Lin Ju, Lei Liang, Lin Wang, Jun Zhou">
  <title>AntBatchInfer: الاستدلال الدفعي المرن في مجموعة Kubernetes</title>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Cairo:wght@400;700&display=swap');
    html, body {
      direction: rtl;
      font-family: 'Cairo', 'Segoe UI', Tahoma, Geneva, Verdana, Arial, sans-serif;
      font-size: 20px;
      background: #f8f9fa;
      color: #222;
      margin: 0;
      padding: 0;
      line-height: 1.8;
    }
    header {
      background: linear-gradient(90deg, #3a8dde 0%, #6dd5ed 100%);
      color: #fff;
      padding: 40px 0 20px 0;
      text-align: center;
      margin-bottom: 40px;
      box-shadow: 0 2px 8px rgba(58,141,222,0.08);
    }
    h1.title {
      font-size: 2.5em;
      font-weight: 700;
      margin-bottom: 10px;
      letter-spacing: 1px;
    }
    .author {
      font-size: 1.1em;
      margin-top: 0;
      color: #e3f2fd;
      letter-spacing: 0.5px;
    }
    h1, h2, h3 {
      color: #3a8dde;
      font-weight: 700;
      margin-top: 2.2em;
      margin-bottom: 0.7em;
      line-height: 1.3;
    }
    h1 {
      font-size: 2em;
      border-bottom: 2px solid #3a8dde;
      padding-bottom: 0.2em;
      margin-bottom: 1.2em;
    }
    h2 {
      font-size: 1.5em;
      border-right: 4px solid #6dd5ed;
      padding-right: 10px;
      margin-bottom: 0.8em;
    }
    h3 {
      font-size: 1.2em;
      color: #1976d2;
      margin-bottom: 0.5em;
    }
    p {
      margin: 0 0 1.2em 0;
      text-align: justify;
    }
    strong {
      color: #1976d2;
    }
    code, .math.inline {
      background: #e3f2fd;
      color: #1976d2;
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.95em;
      font-family: 'Cairo', 'Consolas', 'monospace';
    }
    .nodecor {
      text-decoration: none;
      color: #1976d2;
      font-weight: 600;
    }
    ul, ol {
      margin: 0 0 1.2em 2em;
      padding: 0;
    }
    li {
      margin-bottom: 0.5em;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      margin: 1.5em 0;
      background: #fff;
      box-shadow: 0 1px 4px rgba(58,141,222,0.07);
    }
    th, td {
      border: 1px solid #b3d7f5;
      padding: 10px 14px;
      text-align: center;
    }
    th {
      background: #e3f2fd;
      color: #1976d2;
      font-weight: 700;
    }
    blockquote {
      border-right: 5px solid #6dd5ed;
      background: #f1f8fb;
      color: #1976d2;
      margin: 1.5em 0;
      padding: 1em 1.5em;
      border-radius: 6px;
      font-size: 1.05em;
    }
    section {
      margin-bottom: 2.5em;
    }
    .container {
      max-width: 1040px;
      margin: 0 auto;
      padding: 0 22px;
    }
    @media (max-width: 800px) {
      body {
        font-size: 18px;
      }
      header {
        padding: 25px 0 10px 0;
      }
      h1.title {
        font-size: 1.5em;
      }
      h1, h2 {
        font-size: 1.2em;
      }
      .container {
        padding: 0 14px;
      }
    }
  </style>
</head>
<body>
<header>
  <h1 class="title">AntBatchInfer: الاستدلال الدفعي المرِن في مجموعة Kubernetes</h1>
  <p class="author">
    <span class="nodecor">Siyuan Li</span>,
    <span class="nodecor">Youshao Xiao</span>,
    <span class="nodecor">Fanzhuang Meng</span>,
    <span class="nodecor">Lin Ju</span>,
    <span class="nodecor">Lei Liang</span>,
    <span class="nodecor">Lin Wang</span>,
    <span class="nodecor">Jun Zhou</span>
  </p>
</header>

<main class="container">
  <section>
    <h1 id="ملخص">مُلخّص</h1>
    <p>الاستدلال الدُفعي غير التفاعلي هو مهمة شائعة في الصناعة لتطبيقات التعلُّم العميق، لكن قد يكون من الصعب ضمان الاستقرار والأداء عند التعامل مع كميات كبيرة من البيانات وخطوط استدلال معقّدة. تقدّم هذه الورقة AntBatchInfer، وهو إطار عمل للاستدلال الدُفعي المرِن، مُحسَّن خصيصًا للعناقيد غير المُخصَّصة. يُعالج AntBatchInfer هذه التحديات عبر تقديم قدرات تحمُّل أعطال متعددة المستويات، ما يُمكِّن من تنفيذ مهام الاستدلال المتنوّعة وطويلة الأمد بثبات. كما يُعزّز كفاءة الاستدلال عبر التشغيل على شكل خطّ أنابيب والتوسّع داخل العقدة و跨 العقد. ويُحسّن الإطار الأداء في سيناريوهات الاستدلال الدُفعي المعقّدة متعدّدة النماذج. من خلال تجارب مكثّفة وقياسات واقعية، نُبرز تفوُّق إطارنا من حيث الاستقرار والكفاءة. في التجارب، تفوّق على الخطّ الأساسي بما لا يقلّ عن <span class="nodecor">2<span class="math inline">\( \times \)</span></span> في استدلال النموذج المفرد وحوالي <span class="nodecor">6<span class="math inline">\( \times \)</span></span> في الاستدلال متعدّد النماذج. كما أنه يُستخدم على نطاق واسع داخل عنقود Ant، مع آلاف الوظائف اليومية في سيناريوهات متنوّعة، بما في ذلك DLRM، ورؤية الحاسوب (CV)، ومعالجة اللغات الطبيعية (NLP)، بما يبرهن على قابليته للتطبيق صناعيًا.</p>
  </section>

  <section>
    <h1 id="المقدمة">المقدّمة</h1>
    <p>في الصناعة، يمكن تصنيف نشر نماذج التعلُّم العميق إلى نوعين: الاستدلال الدُفعي غير التفاعلي والاستدلال التفاعلي المتّصل. على عكس الاستدلال المتّصل ذي الحساسية الزمنية العالية، فإن الاستدلال الدُفعي أقلّ تأثُّرًا بالزمن لكنه يتطلّب إنتاجية عالية. هذا يجعله مثاليًا لأحمال العمل التجارية الضخمة التي لا تتطلّب نتائج فورية، وهو منتشر على نطاق واسع في البيئات الصناعية. على سبيل المثال، تُتيح دفعات الاستدلال إجراء الاستدلال على الرسم البياني الكامل للشبكات العصبية البيانية (GNN) الصناعية التي قد تحتوي على ملايين أو حتى مليارات العُقَد، لاكتشاف العلاقات الاجتماعية المحتملة (<span class="nodecor">zhangagl</span>).</p>
    <p>للأسف، معظم الأعمال والأنظمة الحالية مكرّسة للاستدلال المتّصل، في حين نادرًا ما تتناول الأعمال منهجية الاستدلال الدُفعي في الإنتاج، على الرغم من أهميته للتطبيقات الصناعية. إحدى الطرق المباشرة هي تطبيق خطّ أنابيب الاستدلال المتّصل على مهام الدُفعات. ومع ذلك، للاستدلال الدُفعي خصائصُ تُميّزه عن الاستدلال المتّصل، مثل أحمال العمل الضخمة غير الحسّاسة للزمن ومتطلّبات التحكّم في التكلفة (<span class="nodecor">azure_batch_infer</span>). على سبيل المثال، قد تبلغ البيانات المطلوب معالجتها تيرابايتات في بيئات الإنتاج. وهناك طريقة أخرى تعتمد على أنظمة معالجة الدُفعات مثل MapReduce وSpark، التي تستطيع معالجة مجموعات بيانات ضخمة مع ضمان الكفاءة وتحمُّل الأخطاء. إلّا أنها لا تُناسب جيدًا استدلال النماذج الكبيرة أو المعقّدة. فغالبًا ما تحتاج نماذج التوصية العميقة إلى توزيع معلمات ضخمة مُتناثِرة عبر عدة خوادم معلمات (<span class="nodecor">li2014scaling</span>). علاوة على ذلك، تفتقر الأنظمة المستندة إلى MapReduce إلى المرونة عند تنفيذ خطوط أنابيب استدلال معقّدة متعدّدة النماذج ذات مستويات تعقيد متباينة. لذا يبدو الحلّ الأمثل هو تشغيل هذه النماذج في عنقود حاويات مثل Kubernetes.</p>
    <p>ومع ذلك، تواجه أنظمة الاستدلال الدُفعي الحالية على Kubernetes مشكلتين رئيسيتين: الاستقرار (تحمُّل الأخطاء) والكفاءة. يقوم النهج التقليدي على توزيع مجموعة البيانات بالتساوي بين العُمّال داخل الحاويات ومعالجة الحسابات بموازاة البيانات. أولًا، تحمُّل الأخطاء أمر أساسي في الاستدلال الدُفعي على العناقيد غير المُخصّصة (أو المشتركة)، حيث قد يقوم المُجدوِل بإخلاء الحاويات لتلبية اتفاقيات مستوى الخدمة للوظائف الحسّاسة (<span class="nodecor">bernstein2014containers</span>). وبينما تُوفّر معظم خدمات الاستدلال الدُفعي السحابية (<span class="nodecor">aws_sagemaker</span>, <span class="nodecor">vertex_inference</span>) تحمُّل أخطاء على مستوى الحاوية ومرونة داخل العقدة (توسيع/تقليص ديناميكي)، فإنها لا تتعامل مع تحمُّل الأخطاء على مستوى التطبيق وقت التشغيل، كأخطاء التحميل أو انتهاء المهلة. ثانيًا، لا تستفيد هذه الأنظمة استفادة كاملة من الموارد الحاسوبية، لا سيّما في سيناريوهات الاستدلال متعدّد النماذج أو أساليب التجزئة. فعلى سبيل المثال، يؤدّي تخصيص وحدة معالجة رسومات لكل عملية استدلال إلى هدر موارد عندما يكون النموذج بسيطًا. وفي سيناريو الاستدلال متعدّد النماذج، مثل التعرّف على الوجه، يتطلّب خطّ العمل مرحلتين: كشف الكائنات ثم تصنيف الصور. لكن في الأنظمة الحالية، مثل Azure Batch (<span class="nodecor">azure_batch_infer</span>) وGoogle Vertex (<span class="nodecor">vertex_inference</span>)، غالبًا ما يُدمَج النموذجان في المتنبّئ نفسه رغم اختلاف أحمال العمل بينهما.</p>
    <p>لذلك، نُقدّم نظام استدلال دُفعي مبنيًّا على Kubernetes يُعالج منهجيًا مشكلات الاستقرار والأداء من منظور الإطار. أولًا، صمّمنا آلية تحمُّل أعطال دقيقة الحُبَيْبات لضمان الاستقرار على امتداد خطّ أنابيب الاستدلال. ثانيًا، نقترح خطوط أنابيب تستفيد كامل الاستفادة من الموارد الحاسوبية، مع التوسّع داخل العقدة وعبر العقد لكلٍّ من الاستدلال أحاديّ النموذج ومتعدّد النماذج. أخيرًا، نُقدّم واجهة استخدام بسيطة متكاملة مع واجهات خلفية متعدّدة، ونُثبت تفوّق نظامنا في الاستقرار والكفاءة من خلال تجارب مكثّفة.</p>
  </section>

  <section>
    <h1 id="تحليل-المشكلة">تحليل المشكلة</h1>
    <p>لنأخذ في الاعتبار خطّ أنابيب الاستدلال الدُفعي النموذجي الذي يتكوّن من استيعاب البيانات، وتجهيزها، واستدلال النموذج، ثم حفظ النتائج. تقرأ وحدة استيعاب البيانات العينات من مصادر متعددة مثل تخزين الكائنات وقواعد البيانات. ثم تُجهّز وحدة تجهيز البيانات هذه العينات بتنفيذ مهام مثل الترميز في معالجة اللغات الطبيعية أو تعزيز البيانات في رؤية الحاسوب، يليها استدلال النموذج. أخيرًا، تُحفَظ نتائج التنبؤ في نظام التخزين لاستخدامها في التطبيقات اللاحقة. عادةً ما يحتفظ الاستدلال الدُفعي الموزّع بنسخة كاملة من معلمات النموذج في كل عقدة ويُنفّذ الاستدلال على أجزاء بيانات موزّعة مسبقًا.</p>
    <p>دعونا نحلّل أكثر المشكلات المتعلقة بالاستقرار والكفاءة عبر هذا الخطّ. من ناحية الاستقرار، هناك خطر كبير بفشل الوظائف طويلة الأمد، مما يسبّب محاولات إعادة تشغيل متكرّرة. وهذا يؤثّر سلبًا في كفاءة الاستدلال، لا سيّما في العناقيد المشتركة. نُصنّف هذه الأخطاء إلى ثلاث فئات: أخطاء على مستوى الحاوية، وأخطاء التطبيق، وأخطاء البيانات. أولًا، تُعزى أخطاء الحاوية إلى إخفاقات الأجهزة، ومشكلات الإدخال/الإخراج، وإخلاء الحاويات. ثانيًا، قد تواجه تطبيقات التعلُّم العميق أخطاء أثناء معالجة مجموعات البيانات الكبيرة، مثل قيم NaN في العينات، أو أخطاء التحليل، أو العمليات المُعلَّقة. هذه الأخطاء شائعة في مختلف مراحل الخطّ، لكنها تختلف عن أخطاء الحاوية لأنها لا تتطلّب استبدال الحاوية. ثالثًا، يجب تصميم تحمُّل أخطاء البيانات بعناية، حتى لا تضيع عينات أو تتكرّر عند معالجة الاستبدالات، ما قد يضرّ بسلامة البيانات.</p>
    <p>كما أنّ تصميم الأنظمة الحالية يطرح تحدّيات في تحقيق الأداء الأمثل لمهام الاستدلال الدُفعي. أولًا، الوحدات المكثّفة للإدخال/الإخراج مثل الاستيعاب وإعادة الكتابة تُثقِل كاهل الـ I/O، بينما تجهيز البيانات واستدلال النموذج مكثّفان للحساب، ولكلٍّ منهما خصائص موارد مميّزة؛ فاستدلال النموذج يرتكز عادةً على الـ GPU وتجهيز البيانات على الـ CPU. لذا من غير الفعّال تجميع هذه الوحدات المتباينة في حاوية واحدة، إذ قد يصبح خطّ الأنابيب عنق زجاجة. ثانيًا، في سيناريوهات الاستدلال متعدّد النماذج، تختلف تعقيدات النماذج بشكل كبير، ومن غير الفعّال دمجها في الوحدة نفسها. ثالثًا، عادةً ما يُنفَّذ الاستدلال الدُفعي على عناقيد غير مُخصّصة، حيث قد تظهر ظاهرة المُتخلّفين (stragglers) بسبب تنافس التطبيقات على الموارد في أوقات الذروة. وهذا يُولِّد مشكلة الذيل الطويل، إذ إنّ حتى التوزيع المتساوي للبيانات يجعل الحاويات السريعة تنتظر الأبطأ، ما يحدّد وقت الانتهاء بالعقدة الأبطأ. أخيرًا، يمكن الاستفادة من الموارد الفارغة في العناقيد خلال فترات انخفاض الحمل لتسريع المهام الدُفعيّة.</p>
  </section>

  <section>
    <h1 id="إطار-عملنا">إطار عملنا</h1>
    <h2 id="هندسة-الإطار">هندسة الإطار</h2>
    <p>لضمان استقرار وكفاءة الاستدلال الدُفعي، نقترح إطار العمل AntBatchInfer. كما هو موضَّح في الشكل [fig:arch]، يتكوّن الإطار من أربع وحدات: خدمة تقسيم البيانات الحافظة للحالة (Stateful DDS)، ومعالج البيانات، والمتحكِّم المرِن، وجدولة المتنبّئ المرِنة. استندنا في التصميم إلى معماريّة السيّد–العامل، حيث تعمل خدمة تقسيم البيانات الحافظة للحالة والمتحكّم المرِن على خادم مخصّص (السيّد)، في حين تنتشر الوحدات الأخرى على عُقَد العامل.</p>
    <p><strong>خدمة تقسيم البيانات الحافظة للحالة (Stateful DDS)</strong> تُوزّع عينات البيانات بمرونة على العُمّال بناءً على قدراتهم، وتُعالج دورة حياة كل «شريحة» بيانات. فهي تحتفظ بقائمة رسائل عالمية تُقسِّم مجموعة البيانات على مستوى الشرائح، وتُدرِج كل شريحة (التي تحتوي على فهارس العينات فقط) في القائمة ليستهلكها العُمّال. يُيسِّر هذا إعادة توازن الأحمال بين العُقَد القوية والضعيفة، مع تجاوز مشكلة الذيل الطويل المرتبطة بالتقسيم المتساوي. كذلك، تُدير الخدمة حالة كل شريحة (قيد الانتظار "TODO"، قيد المعالجة "DOING"، مكتملة "DONE")، مما يُعزّز تحمُّل أخطاء البيانات عبر إعادة توزيع الشرائح عند حدوث فشل.</p>
    <p><strong>معالج البيانات</strong> مسؤول عن الـ I/O وتجهيز البيانات كثيفة الحساب. يتعاون مع الـ DDS لتحميل البيانات ومزامنة الحالة. تحديدًا، يجلب المعالج في كل عامل العينات الفعلية وفقًا للبيانات التعريفية، ثم يُجهّزها مسبقًا ويضع النتائج في قائمة انتظار للاستدلال. وقد أضفنا تحسينات لملفات صغيرة عبر الدمج والتخزين المؤقّت القريب قبل الاستدلال. وأخيرًا، يُبلّغ عن اكتمال الشريحة بعد كتابة النتائج في التخزين.</p>
    <p><strong>المتحكِّم المرِن</strong> يُدير موارد العُقَد طوال وظيفة الاستدلال الدُفعي ويتحكّم في تحمُّل أخطاء الحاويات. يُراقب أحداث Kubernetes عبر عقدة السيّد (Master)، بما في ذلك خصائص الموارد وإطلاق الحاويات، ويُعيد تشغيل الحاويات عند استثناءات قابلة لإعادة المحاولة (أعطال الأجهزة، أخطاء الشبكة، الإخلاء) أو يتوقّف عن إعادة التشغيل عند أخطاء غير قابلة للإصلاح (أخطاء التهيئة أو البرمجية). كما يسمح بالتوسّع أو التقليل الديناميكي لعُقَد الحوسبة عبر تقدير دوري للاحتياج من الموارد، ما يُسرّع الدُفعات في ساعات الذروة المنخفضة. عند فشل عقدة، يُحوِّل المُتحكِّم الدُفعة إلى عقدة جديدة بالتنسيق مع DDS لضمان سلامة البيانات وتفادي التكرار.</p>
    <p><strong>جدولة المتنبّئ المرِنة</strong> تُوفّر توسّعًا داخل العقدة لوظائف استدلال النموذج. صُمّم هذا المكوّن لثلاثة أهداف: أولًا، إدارة التزامن داخل العملية عبر ضبط عدد خيوط/عمليات التحميل، والاستدلال، والكتابة استنادًا إلى تقدير الموارد. ثانيًا، تحمُّل أخطاء التطبيق عن طريق إعادة تشغيل العمليات المُعلَّقة والتعامل مع تسريبات الذاكرة. ثالثًا، دعم مستويات توازٍ مختلفة للاستدلال متعدّد النماذج عبر قائمة انتظار خالية من الإقفال للتنسيق بين المتنبّئين.</p>

    <h2 id="التحسين-من-أجل-الاستقرار">التحسين من أجل الاستقرار</h2>
    <p>تستعرض هذه الفقرة آليات تحمُّل الأخطاء متعددة المستويات في AntBatchInfer. نُصنّف التحمُّل إلى ثلاثة مستويات: تحمُّل أخطاء الحاوية، وتحمُّل أخطاء التطبيق، وتحمُّل أخطاء البيانات.</p>
    <h3 id="تحمل-أخطاء-الحاوية">تحمُّل أخطاء الحاوية</h3>
    <p>يُراقب المُتحكِّم المرِن دوريًا أحداث الحاويات عبر السيّد في Kubernetes، ويُصنّف الانهيارات إلى أخطاء قابلة لإعادة المحاولة (شبكة، أجهزة، إخلاء الحاويات) وأخطاء غير قابلة لإعادة المحاولة (أخطاء تهيئة أو برمجية). عند وقوع خطأ قابل لإعادة المحاولة، يبدأ المُتحكِّم حاوية جديدة ويسحب شريحة بيانات مناسبة من DDS. وعند ورود أحداث تقليل الموارد، يُوقِف الحاوية المتأثّرة.</p>
    <h3 id="تحمل-أخطاء-التطبيق">تحمُّل أخطاء التطبيق</h3>
    <p>تُراقب جدولة المتنبّئ المرِنة حالة العمليات محليًا أثناء الاستدلال. أولًا، نلتقط الأخطاء القابلة للتحمّل عبر خطّ الأنابيب (أخطاء جلب البيانات، أو التحليل، أو الاستدلال) ونربطها بالعينات ذات الصلة ونخزّنها في التخزين مع معلومات الخطأ لمساعدة المستخدمين في تشخيص المشكلات. ثانيًا، نُعيد تشغيل العمليات عند حدوث أخطاء غير متوقّعة باستخدام آلية إعادة المحاولة مع مهلات، مثل العمليات المُعلَّقة أو تسريبات الذاكرة في شيفرة المستخدم.</p>
    <h3 id="تحمل-أخطاء-البيانات">تحمُّل أخطاء البيانات</h3>
    <p>عند فشل عامل، يلتقط عامل جديد شرائح بيانات في حالة “TODO” من DDS ويبدأها. تُعلَّم الشريحة بـ “DOING” عند بدء الاستدلال، ويُنفِّذ المتنبّئ حساب النموذج. بعد تسجيل النتائج في التخزين، يُبلِّغ معالج البيانات عن الشريحة وتُعلَّم “DONE” في DDS. وإذا اكتشف المُتحكِّم المرِن فشل عقدة أو حدث توسّع/تقليص، تُعاد الشريحة المعلَّمة “DOING” إلى “TODO” في نهاية قائمة DDS، مما يضمن عدم فقدان البيانات أو تكرارها.</p>

    <h2 id="التحسين-من-أجل-الكفاءة">التحسين من أجل الكفاءة</h2>
    <h3 id="تقليل-الوقت-الكلي-لإتمام-العمل">تقليل الوقت الكلي لإتمام العمل</h3>
    <p>يُقلِّل DDS الوقت الكلّي لإتمام المهمّة ويستفيد من الموارد عبر تخصيص ديناميكي للعينات لكل عامل حسب معدل الإنتاجية الفعلي. هذا يُحقّق توازن الأحمال طبيعيًا ويُقلِّص مدة الإنجاز التي غالبًا ما تُحدِّدها العُقَد الأبطأ في التقسيم المتساوي. إضافةً إلى ذلك، يدعم المُتحكِّم المرِن توسيع عدد العُمّال لتحسين الكفاءة عند انخفاض التحميل على العنقود.</p>
    <h3 id="تسريع-الاستدلال-الدفعي-لنموذج-واحد">تسريع الاستدلال الدُفعي لنموذج واحد</h3>
    <p>يُسرِّع AntBatchInfer استدلال نموذج واحد عبر تقسيمه إلى ثلاث مراحل متوازية: التحميل، والاستدلال، والكتابة. تُنفَّذ هذه المراحل في خيوط أو عمليات منفصلة، ويضبط المُجدول داخل العقدة مستويات التزامن استنادًا إلى قائمة انتظار خالية من الإقفال وخوارزمية تقديرية. فعندما تكون قائمة انتظار الاستدلال شبه فارغة، يُزاد عدد عمليات التحميل، وعندما تمتلئ، تُزاد عمليات الاستدلال إذا توفّر CPU/GPU. ويُزاد خيط الكتابة عند امتلاء قائمة الكتابة، مما يُعظّم استخدام الموارد ويُقصِّر زمن المعالجة الإجمالي.</p>
    <h3 id="تسريع-خط-أنابيب-الاستدلال-الدفعي-للنماذج-المتعددة">تسريع خطّ أنابيب الاستدلال الدُفعي للنماذج المتعدّدة</h3>
    <p>لتسريع الاستدلال الدُفعي المتعدّد، نُغلِّف كل نموذج في متنبّئ مستقل ضمن رسم بياني مُوجّه يعكس التتابع المنطقي. كل متنبّئ يتعامل مع نموذج واحد ويمكنه تعديل عدد وحدات المعالجة الرسومية المستخدمة بحسب تعقيد النموذج. وعند وصول حجم الدُفعة إلى القيمة المستهدفة في أي مرحلة، يبدأ المتنبّئ التالي بالمعالجة فورًا. وتُجمَّع النتائج قبل الكتابة عبر قائمة انتظار مشتركة في الذاكرة، ما يُجنِّب إعادة تهيئة CUDA المتكرّرة عند تغيّر حجم الدُفعة. على سبيل المثال، يُخرِج نموذج كشف الأجسام عددًا متغيّرًا من الكائنات، تُستخدم لاحقًا في نموذج التصنيف.</p>
  </section>

  <section>
    <h1 id="العرض-التوضيحي">العرض التوضيحي</h1>
    <p>في العرض التوضيحي، نُبرز بساطة واجهة الاستخدام لـ <span class="nodecor">AntBatchInfer</span> ونُقدّم سيناريو استدلال دُفعي لمهمة تصنيف الصور، كما في الشكل <span class="nodecor">3</span>. ويمكن تطبيق التكوينات التالية على مهام ودُفعات أخرى بسهولة. <span class="nodecor">1)</span> يُحدّد <span class="nodecor">EngineConfig</span> موارد الأجهزة، مع مُعامِل أولوية يتيح تخصيص نسبة (مثل <span class="nodecor">60%</span>) موارد مضمونة والباقي موارد فُرصيّة (Spot). <span class="nodecor">2)</span> يضبط <span class="nodecor">DataHandler</span> مصدر البيانات وعدد العُمّال (<span class="nodecor">num_workers</span>) للتحكّم بالتزامن، بديلًا عن <span class="nodecor">DataLoader</span> في PyTorch و<span class="nodecor">Dataset</span> في TensorFlow. <span class="nodecor">3)</span> يُحدّد <span class="nodecor">WriterConfig</span> نظام التخزين المستهدف وعدد خيوط الكتابة. <span class="nodecor">4)</span> يُحدّد <span class="nodecor">ElasticPredictionRunnerConfig</span> مسار النموذج وعدد المتنبّئين، بالإضافة إلى وظائف المعالجة المُسبقة واللاحقة. يمكن للمستخدم تفعيل التوسّع التلقائي داخل العقدة أو تحديد عدد العمليات يدويًا. كما نوفّر واجهة ويب رسومية لغير المتخصّصين، مع تفاصيل إضافية في الفيديو التوضيحي.</p>
  </section>

  <section>
    <h1 id="التجارب">التجارب</h1>
    <p>في هذا القسم، نعرض كفاءة <span class="nodecor">AntBatchInfer</span>، مع إبراز قدرات تحمُّل الأخطاء متعددة المستويات والمرونة عبر مقاطع توضيحية باستخدام <span class="nodecor">TensorFlow</span> و<span class="nodecor">PyTorch</span> و<span class="nodecor">ONNX</span> كواجهات خلفية. أولًا، نقيم أداء <span class="nodecor">AntBatchInfer</span> في مهمة استدلال دُفعي لنموذج شبكي (GNN) من نوع <span class="nodecor">TGAT</span> (<span class="nodecor">xu2020inductive</span>) مع نصف مليار عقدة و<span class="nodecor">6</span> مليارات حافة، حيث تُعالَج <span class="nodecor">260</span> مليون عيّنة يوميًا في عنقود <span class="nodecor">CPU</span> غير مُخصّص. تُظهر النتائج أن <span class="nodecor">AntBatchInfer</span> أسرع بما لا يقلّ عن مرّتين من الخطّ الأساسي بفضل خطوط الأنابيب والتوسّع داخل العقدة، إذ بلغ معدّل الاستعلامات 1200 مقابل 550 استعلام/ثانية. ثانيًا، نجري استدلالًا دُفعيًا في سيناريو متعدّد النماذج على وحدات <span class="nodecor">Nvidia A100</span>، حيث المرحلة الأولى كشف الأجسام بنموذج <span class="nodecor">SCRFD</span> (<span class="nodecor">guo2021sample</span>) والمرحلة الثانية تصنيف الصور بـ <span class="nodecor">ResNet</span> (<span class="nodecor">he2016deep</span>)؛ وتبيّن أن <span class="nodecor">AntBatchInfer</span> أسرع بحوالي ست مرّات (398 مقابل 68 استعلام/ثانية). ثالثًا، نقارن وقت الانتهاء بين التقسيم المتساوي وطريقة <span class="nodecor">DDS</span> في سيناريو النماذج المتعدّدة، فحقّقت <span class="nodecor">DDS</span> تسريعًا من 12% إلى 30% على <span class="nodecor">A100</span>، مع فجوة أكبر في العناقيد غير المُخصّصة. أخيرًا، يُظهر التوسّع الخطي حتى 120 عقدة <span class="nodecor">CPU</span> (كلٌّ منها 20 نواة) أن تكلفة المزامنة بين <span class="nodecor">DDS</span> وعُقَد العُمّال ضئيلة.</p>
  </section>
</main>
</body>
</html>