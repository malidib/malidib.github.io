<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <meta name="author" content="RaGon Ebker">
  <title>حلّ المعادلات الحدودية غير القابلة للفصل فوق حقل سلاسل Puiseux عبر الرفع الذهبي</title>
  <style type="text/css">code{white-space: pre;}</style>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <style>body { direction: rtl; font-size: 22px; }</style>
</head>
<body>
<header>
<h1 class="title">حلّ المعادلات الحدودية غير القابلة للفصل فوق حقل سلاسل <span class="nodecor">Puiseux</span> عبر الرفع الذهبي</h1>
<p class="author"><span class="nodecor">RaGon Ebker</span></p>
</header>
<h1 id="abstract">مُلخّص</h1>
<p>نطوّر طريقة تكرارية لحساب جذور المعادلات الحدودية التعسفية فوق حقل سلاسل <span class="nodecor">Puiseux</span> بما في ذلك تلك غير القابلة للفصل. تعمل الطريقة عبر تحويل المعادلة الحدودية وجذورها إلى شكل خاص ثم استخراج معادلة حدودية أحادية الحد جديدة تحتوي على معلومات حول جذورنا. نوفر أيضًا تنفيذًا عمليًا للخوارزمية بلغة <span class="nodecor">Python</span>.</p>
<h1 id="notation">التدوين</h1>
<p>لتكن <span class="math inline">\(\mathbb{N}\)</span> مجموعة الأعداد الطبيعية بما في ذلك <span class="nodecor">0</span>. وليكن <span class="math inline">\(K\)</span> حقلًا و<span class="math inline">\(K((x^\frac{1}{n}))\)</span> هو حقل سلاسل بويزو العاملة فوق <span class="math inline">\(K\)</span>. عناصر <span class="math inline">\(K((x^\frac{1}{n}))\)</span> تكون على الشكل <span class="math inline">\(y = \sum_{k=k_0} ^\infty b_{k}x ^{\frac{k}{n}}, n \in \mathbb{Z}\)</span>. عندما يكون لـ<span class="math inline">\(y\)</span> عدد محدود من الحدود، نسمّي <span class="math inline">\(d_x\)</span> درجة <span class="math inline">\(y\)</span>. وليكن <span class="math inline">\(Q : K((x)) \mapsto K((x))\)</span> معادلة حدودية فوق حقل سلاسل بويزو، <span class="math inline">\(Q(y) = a_{d_y} y^{d_y} + ... + a_1 y + a_0, d_y \in \mathbb{N^+}\)</span>، حيث <span class="math inline">\(d_y\)</span> هي درجة <span class="math inline">\(Q\)</span>. وليكن <span class="math inline">\(\alpha =  \sum_{k=0} ^\infty b_{k}x ^{\frac{k}{n}}, n \in \mathbb{Z}\)</span> جذرًا لـ<span class="math inline">\(Q\)</span>.</p>
<p>تكون المعادلة الحدودية ذات ضربية-س، عندما توجد <span class="math inline">\(s\)</span> جذور <span class="math inline">\(\alpha_1,...,\alpha_s\)</span> لـ<span class="math inline">\(Q\)</span> بحيث تكون معاملات <span class="math inline">\(b_0\)</span> جميعها صفرًا.</p>
<p>تكون المعادلة الحدودية <span class="math inline">\(Q\)</span> ذات ضربية-س-زائدة، عندما توجد جذور <span class="math inline">\(s^+\)</span> <span class="math inline">\(\alpha_1,...,\alpha_{s^+}\)</span> لـ<span class="math inline">\(Q\)</span>، <span class="math inline">\(s^+ \in \{1,...,s\}, s\)</span> هي الضربية-س لـ<span class="math inline">\(Q\)</span> بحيث تكون معاملات <span class="math inline">\(b_0\)</span> جميعها صفرًا والحد <span class="math inline">\(b_1\)</span> له نفس التقييم لجميع <span class="math inline">\(\alpha_j, j \in \{1,...,s^+\}\)</span>.</p>
<p>المعادلة الحدودية <span class="math inline">\(Q(y) = (y-(1+x+x^2))(y-x^{0.5})(y-x^{0.6})(y-x^{0.5} + x^2)\)</span> لها ضربية-س <span class="nodecor">3</span> وضربية-س-زائدة <span class="nodecor">2</span>.</p>
<p>ليكن <span class="math inline">\(v: K((x)) \mapsto \mathbb{Q}\)</span> خريطة التقييم المعرفة بـ<span class="math inline">\(v(y) = k_0\)</span>.</p>
<h1 id="introduction">مقدمة</h1>
<p>لنتخيل للحظة أن لدينا خوارزمية لحساب أصغر جذر لمعادلة حدودية <span class="math inline">\(Q\)</span>، على سبيل المثال، <span class="math inline">\(Q(y) = (y - (1+x+x^2)) (y-(2+x+x^2))\)</span> فوق حقل سلاسل Puiseux. في هذه الحالة، الجذر الأصغر هو <span class="math inline">\((1+x+x^2)\)</span>. الأصغر هنا يعني الجذر الذي يحتوي على معامل رئيسي بأصغر تقييم، في هذه الحالة. لكن يمكننا فقط حساب الحد الأعلى تقييمًا، أي <span class="math inline">\(1\)</span>. كيف يمكننا المضي قدمًا لحساب الحدود التالية للجذر؟ قد تبدو الإجابة واضحة: من خلال تحويل جذور معادلة الحدود <span class="math inline">\(Q\)</span>. الآن لدينا معادلة الحدود المحوّلة <span class="math display">\[Q_{shift} = (y - (x+x^2)) (y-(1x+x^2))\]</span> ويمكننا بسهولة حساب الحد التالي بخوارزميتنا: <span class="math inline">\(x\)</span>. في هذه الورقة سنستكشف هذه الفكرة بشكل رئيسي: 1. كيفية تطوير خوارزمية لحساب أصغر جذر تحت ظروف معينة 2. كيفية تحويل معادلة الحدود لدينا لتلبية هذا الشرط. يمكن أيضًا رؤية نظرة عامة جيدة لهذه العملية في القسم [algorithm]. توجد طرق مماثلة لحل هذه المشكلة عبر سلاسل Puiseux وسلاسل القوى، على سبيل المثال في صيغة قاعدة Hensel ونُسخها المطورة (<span class="nodecor">neiger</span>) أو في طريقة Newton Puiseux (<span class="nodecor">brieskorn2012plane</span>).</p>
<h1 id="main">النتيجة الرئيسية</h1>
<p>في هذا القسم، نعرض النتيجة الرئيسية. تعمل هذه الطريقة عبر تقليص معادلتنا الحدودية إلى معادلة حدودية أصغر، تحت شروط معينة. في القسم <span class="nodecor">4</span> سنرى كيف يمكننا تحويل أي معادلة حدودية إلى واحدة تحقق هذه الشروط بالضبط. نحسب جذر معامل معادلتنا الحدودية معاملًا تلو الآخر كما في خوارزمية نيوتن-بويزو الأصلية.</p>
<p>لتكن <span class="math inline">\(Q : K((x)) \mapsto K((x))\)</span> معادلة حدودية فوق حقل سلاسل بويزو، <span class="math inline">\(Q(y) = a_{d_y} y^{d_y} + ... + a_1 y + a_0, d_y \in \mathbb{N^+}\)</span>. ولتكن <span class="math inline">\(\alpha_1,...,\alpha_n\)</span> جذور معادلتنا الحدودية ولتكن <span class="math inline">\(v(a_i) \geq 0, i \in \{1,...,d_y\}\)</span>. الآن نفترض <span class="math inline">\(v(\alpha_j) \geq e &gt; 0 \  , j \in \{1,...,s\}\)</span>، <span class="math inline">\(s \in \{1,...,d_y-1\} , e \in \mathbb{Q}\)</span>، مع <span class="math inline">\(v(\alpha_j) = e\)</span> لـ<span class="math inline">\(j \in \{1,...,s^+\}, s^+ &gt;1\)</span>. <span class="math inline">\(s\)</span> هي بالضبط ضربية-س لـ<span class="math inline">\(\alpha_j\)</span>، <span class="math inline">\(s^+\)</span> هي ضربية-س-زائدة. <span class="math inline">\(e\)</span> هو أصغر تقييم لجميع <span class="math inline">\(\alpha_j\)</span>. يمكننا أيضًا تمثيل هذه الجذور كـ<span class="math inline">\(\alpha_j = c_{1_j} x^{e} + c_{2_j} x^{e + \gamma_{2_j}} + c_{3_j} x^{e + \gamma_{2_j} + \gamma_{3_j}} ..., \gamma_j \in \mathbb{Q}, j \in \{1,...,s^+\}.\)</span> الآن الهدف من هذه النظرية هو حساب <span class="math inline">\(c_{1_j}, j \in \{1,...,s^+\} \)</span>. نفترض أيضًا <span class="math inline">\(v(\alpha_j) = 0, \ \forall j \in \{s+1,...,d_y\}.\)</span> ننظر الآن إلى معاملات <span class="math inline">\(Q\)</span>. نتذكر <span class="math display">\[a_i = b_{i_0}x^{\delta_1} + b_{i_1}x^{\delta 1 + \delta_2} + ..., \ \delta_k \in \mathbb{Q}, k \in \mathbb{N^+} .\]</span> لنكن الآن <span class="math inline">\(Q_R(x) = b_{s_{min}}x^{d_y} + ... + b_{1_{min}} x\)</span> حيث <span class="math inline">\(b_{i_{min}} := \min_{l \in \{1,...,d_x\}} \{b_{i_l} \neq 0 \}, i \in \{1,...,s\}\)</span>. إذًا جذور <span class="math inline">\(Q_R\)</span> هي بالضبط <span class="math inline">\(c_{1_j}\)</span>. إذًا <span class="math inline">\(Q_R\)</span> من الدرجة <span class="math inline">\(s\)</span>، وجذور <span class="math inline">\(c^+\)</span> هي بالضبط <span class="math inline">\(c_{1_j} j \{1,...,s^+\}\)</span> التي تنتمي إلى الجذور ذات التقييم الأدنى. الجذور الأخرى <span class="math inline">\(s-s^+\)</span> هي صفر.</p>
<p>نعلم أن <span class="math inline">\(c_{1_j}, j \in \{1,...,s^+\}\)</span> كونها المعامل الصحيح لجذر <span class="math inline">\(Q\)</span> يعادل <span class="math inline">\(Q(c_{1_j} x^{e}) \mod  x^{e&#39;} \equiv 0\)</span>، أي أن <span class="math inline">\(c_{1_j}x\)</span> هو جذر لـ<span class="math inline">\(Q(y) \mod  x^{e&#39;}\)</span>. <span class="math inline">\(e&#39; \in \mathbb{Q}\)</span> هو في هذه الحالة أي رقم أكبر من <span class="math inline">\(s \cdot e\)</span> وأصغر من أي حد من <span class="math inline">\(Q\)</span>، الذي له تقييم أكبر من <span class="math inline">\(e\)</span>. يمكن أيضًا رؤية ذلك من خلال النظر إلى المعادلة الحدودية في تحليلها العاملي. نُظهر أن <span class="math inline">\(Q(\beta x^e) = Q_R(\beta x^e) \mod x^{e&#39;}\)</span>: <span class="math display">\[\begin{aligned}
     Q(\beta x^e) &amp;\equiv  a_{d_y} (\beta x^e)^{d_y} + ... + a_1 \beta x^e + a_0 \mod x^{e&#39;} \\
         &amp;\equiv a_{d_y} ^* (\beta x^e)^{d_y} + ... + a_1^* (\beta x^e) + a_0^* + \left( b_{d_{y_{min}}}(\beta x^e) ^{d_y} + ... + b_{1_{min}}(\beta x^e) + b_{0_{min}} \right) \mod x^{e&#39;} \\
         &amp;\equiv b_{d_{y_{min}}}(\beta x^e)^{d_y} + ... + b_{1_{min}}(\beta x^e) + b_{0_{min}} \mod x^{e&#39;} \\
         &amp;\equiv b_{s_{min}}(\beta x^e)^s + ... + b_{1_{min}}(\beta x^e) + b_{0_{min}} \mod x^{e&#39;} \\\end{aligned}\]</span> حيث <span class="math inline">\(a_i^{*} = a_i - b_{i_{min}}, i \in \{1,...,d_y\}\)</span>.</p>
<p>خلاصة القول: عندما نحل <span class="math inline">\(Q_R\)</span> نحصل على الحلول <span class="math inline">\(c_{1_j}x^e\)</span>. سنشرح كيفية حل <span class="math inline">\(Q_R\)</span> بمساعدة التحويلات في القسم <span class="nodecor">4</span>. لتطبيق هذه النظرية، نحتاج إلى تحقيق الشرط <span class="math inline">\(v(\alpha_j) \geq e &gt; 0, j \in \{1,...,s\}\)</span> مع <span class="math inline">\(v(\alpha_j) = e\)</span> لواحد على الأقل <span class="math inline">\(j \in \{1,...,s\}\)</span> و <span class="math inline">\(v(\alpha_k) = 0, \ \forall k \in \{s+1,...,d_y\}\)</span> (<span class="nodecor">1</span>). نحتاج أيضًا إلى الحصول على <span class="math inline">\(e\)</span> (<span class="nodecor">2</span>) و<span class="math inline">\(s\)</span> (<span class="nodecor">3</span>). بمجرد تطبيق هذه الخطوة، يمكننا استخراج (<span class="nodecor">1</span>), (<span class="nodecor">2</span>)، و(<span class="nodecor">3</span>)، للخطوة التالية، من مجموعة جذور <span class="math inline">\(Q_R\)</span>. يمكننا المضي قدمًا بنفس الطريقة لمتابعة المعاملات التالية <span class="math inline">\(c_{2_k},...,c_{d_{y_l}}\)</span>، بعد تحويل معادلتنا الحدودية لتلبية افتراضنا مرة أخرى. <span class="math inline">\(k\)</span> و<span class="math inline">\(l\)</span> هما الفهارس المقابلة.</p>
<h1 id="التحول-الأولى-للمتعددة-الحدود">التحويل الأولي للمعادلة الحدودية</h1>
<p>في هذا القسم، سنثبت كيفية تحويل معادلة حدودية <span class="math inline">\(Q: K((x^\frac{1}{n})) \mapsto K((x^\frac{1}{n}))\)</span> إلى واحدة تحقق الشرط (1)، إذا لم تكن كذلك بالفعل، وكيفية استخراج (2) و(3). نبدأ أولًا بنظرية معروفة:</p>
<p>لنفترض أن لدينا معادلة حدودية <span class="math inline">\(P\)</span> فوق <span class="math inline">\(K\)</span>، مع <span class="math inline">\(\alpha_1,...,\alpha_n, n \in N^+\)</span> كجذور لها. إذًا لأي ثابت <span class="math inline">\(c \in K\)</span> تكون المعادلة الحدودية ذات الجذور <span class="math inline">\(\alpha_1 + c,...,\alpha_n +c \)</span> على الشكل <span class="math display">\[Q(y)=P(y-c)=a_{n}(y-c)^{n}+a_{n-1}(y-c)^{{n-1}}+\cdots +a_{{0}}.\]</span> والمعادلة الحدودية ذات الجذور <span class="math inline">\(c\alpha_1,...,c\alpha_n\)</span> تكون على الشكل <span class="math display">\[Q(y) = a_{n}y^{n}+a_{n-1}cy^{{n-1}}+\cdots +a_{{0}}c^{n}.\]</span></p>
<p>نبدأ الآن بـ(1). يمكننا التحقق من (1) بحساب الأجزاء الثابتة من الجذور عبر <span class="math inline">\(Q_{|x=0}\)</span>. إذا كان لدينا على الأقل جذر واحد من <span class="math inline">\(Q_{|x=0}\)</span> غير مساوٍ للصفر وآخر مساوٍ للصفر فإننا نحقق الشروط. التحقق من <span class="math inline">\(Q_{|x=0}\)</span>، بشكل رئيسي للحصول على الجزء الثابت من جذر <span class="math inline">\(Q\)</span>، هو تقنية شائعة ويمكن رؤيتها عند النظر إلى <span class="math inline">\(Q\)</span> في تمثيل العوامل الخطية. في الحالة 1 أولًا، نريد التأكد من أن <span class="math inline">\(v(\alpha_j) = 0\)</span> صحيح لواحد على الأقل <span class="math inline">\(i \in \{1,...,d_y\}\)</span>. ماذا لو كانت جميع جذور <span class="math inline">\(Q_{|x=0}\)</span> صفرًا لجميع <span class="math inline">\(j \in \{1,...,d_y\}\)</span>؟ في هذه الحالة، نحول معادلتنا الحدودية عبر الضرب كما في النظرية 1. لهذا الغرض، نحتاج فعليًا إلى معرفة <span class="math inline">\(e\)</span>، تقييم <span class="math inline">\(\alpha_j\)</span>، والذي يمكننا الحصول عليه عبر مضلع نيوتن لمعادلتنا الحدودية. وبالتالي نضرب جذورنا بـ<span class="math inline">\(a^e\)</span>. نعود الآن إلى معادلتنا الحدودية المحوّلة، التي تحقق <span class="math inline">\(v(\alpha_j) = 0\)</span> صحيح لواحد على الأقل <span class="math inline">\(j \in \{1,...,d_y\}\)</span>. في الحالة 2 الآن نتحقق إذا كان <span class="math inline">\(v(\alpha_j) &gt; 0\)</span> صحيح لواحد على الأقل <span class="math inline">\(j \in \{1,...,d_y\}\)</span>. لنفترض أن لدينا <span class="math inline">\(v(\alpha_j) = 0, \forall i \in \{1,...,n\}\)</span>، إذًا يمكننا الحصول على الحد الثابت لـ<span class="math inline">\(\alpha_j\)</span> بتقييم <span class="math inline">\(Q_{|x=0}\)</span> وأخذ جذوره، كما ناقشنا بالفعل. بمجرد حصولنا على جميع الأجزاء الثابتة <span class="math inline">\(c_j\)</span> لـ<span class="math inline">\(\alpha_j\)</span>، سنستخدمها لتحويل معادلتنا الحدودية بمساعدة النظرية 1. إذا انتهينا بمعادلة حدودية تحقق <span class="math inline">\(v(\alpha_j) &gt; 0\)</span> لجميع <span class="math inline">\(j \in \{1,...,d_y\}\)</span>، نعود إلى الحالة 1. إذا لم يكن كذلك، فلدينا واحدة تحقق الشرط المطلوب. الآن يمكننا أخيرًا التحدث عن الحالة عندما يتم تحقيق (1): نحسب جذور <span class="math inline">\(Q_{|x=0}\)</span> أو نأخذ الجذور المحسوبة بالفعل، أحدها الآن غير مساوٍ للصفر. دعونا نسميه <span class="math inline">\(\alpha_k, k \in \{1,...,d_y\}.\)</span> في هذه الخطوة نحصل بالفعل على <span class="math inline">\(s\)</span> -multiplicity لذلك الجذر، وهو بالضبط الضرب الذي نحتاجه لخطوتنا التالية. بعد هذا الحساب، نحول مرة أخرى، وهكذا، نصل إلى جذرنا تدريجيًا.</p>
<h1 id="الخوارزميه">الخوارزمية</h1>
<h1 id="التعقيد">التعقيد</h1>
<h1 id="algorithm">الخوارزمية</h1>
<p>في هذا القسم، سنستكشف الخوارزمية بالتفصيل. يمكن العثور على تنفيذ لها في (<span class="nodecor">ragon</span>). أولًا، نقوم بتعريف فئة المعلومات التي تحفظ كل المعلومات المهمة لدينا. عند تهيئة الخوارزمية، نقوم بإنشاء كائن من فئة المعلومات، مع دقة محددة <span class="math inline">\(d\)</span>، قائمة فارغة root_dict_list، وx_lift بقيمة <span class="math inline">\(0\)</span>. يمكن دائمًا حساب الألفا الحالية من خلال دمج أجزاء جذرنا من root_dict_list. ثم نعطي كائن المعلومات إلى الطريقة calculate_smallest_root، طريقتنا الرئيسية: كما نرى في [alg:calculate]، نتبع العملية الموصوفة في الأقسام 3 و4. نبدأ أولًا بحساب الانتقال الأولي، لجلب معادلتنا الحدودية إلى الشكل <span class="math inline">\(v(\alpha_j) \geq e &gt; 0, j \in \{1,...,s\}\)</span> مع <span class="math inline">\(v(\alpha_j) = e\)</span> لواحد على الأقل <span class="math inline">\(j \in \{1,...,s\}\)</span> و <span class="math inline">\(v(\alpha_k) = 0, \ \forall k \in \{s+1,...,d_y\}\)</span>، كما هو موصوف في (1). في هذه العملية، نحصل بالفعل على الجزء الأول من جذرنا الأول ألفا. هذا يجلب لنا أيضًا <span class="math inline">\(s-\)</span> الضرب من الجزء التالي من الجذر. في الحلقة التكرارية، التي تبدأ في السطر 4، نبدأ بتحويل معادلتنا الحدودية أفقيًا، بحيث نحصل على الشكل (1) مرة أخرى. تحويل المعادلة الحدودية أفقيًا يعني إضافة ثابت إلى جذرها. طريقة الانتقال الأولي تحسب جذور <span class="math inline">\(p_{|x=0}\)</span> في السطر 1 مع get_sub_x_root. ثم نقوم بتحويل معادلتنا الحدودية عموديًا إذا كانت جميع الجذور، في هذه الحالة الموصوفة بواسطة shift_number، غير مساوية للصفر. التحويل العمودي يعني ضرب الجذور بثابت. الخوارزمية [alg:calculate_q] هي نفسها [alg:calculate_i] ولكنها لا تعيد أي شيء. الخوارزمية [alg:golden] تصف بالضبط عملية استخراج <span class="math inline">\(p_R\)</span> من معادلة حدودية <span class="math inline">\(p\)</span>، تمامًا كما استخرجنا <span class="math inline">\(Q_R\)</span> من <span class="math inline">\(Q\)</span> في النظرية 1. هنا من الممكن أيضًا التحقق مما إذا كانت معادلة الحدود <span class="math inline">\(p_R\)</span>، التي تسمى new_poly في الكود والشيفرة الزائفة، لها شكل بسيط جدًا مثل عندما تتكون فقط من جذر واحد بضرب <span class="math inline">\(s\)</span>. هذا يعني أن ضربها <span class="math inline">\(s\)</span> وضربها <span class="math inline">\(s^+\)</span> هما نفس الشيء. ثم نبدأ نفس العملية كما في طريقة الانتقال الأولي لحساب جذور <span class="math inline">\(p_R\)</span> أي new_poly.</p>
</body>
</html>
